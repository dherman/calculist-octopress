<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Little Calculist]]></title>
  <link href="http://calculist.org/atom.xml" rel="self"/>
  <link href="http://calculist.org/"/>
  <updated>2012-04-26T08:38:30-07:00</updated>
  <id>http://calculist.org/</id>
  <author>
    <name><![CDATA[Dave Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The little-endian web!]]></title>
    <link href="http://calculist.org/blog/2012/04/25/the-little-endian-web/"/>
    <updated>2012-04-25T12:29:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/25/the-little-endian-web</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/The_Gates_of_Hell"><img class="right" src="http://calculist.org/images/gates-of-hell.jpg"></a></p>

<blockquote><p><a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">This</a> feels a little bit like the web platform having opened a door to hell and Zombies running out of it. I wonder if we can ever close it again.
&#8211; <a href="https://plus.google.com/u/1/116910304844117268718/posts/9fdegEJkAtt">Malte Ubl</a></p></blockquote>

<p>Let&#8217;s see if we can. I&#8217;ve had a bunch of productive conversations since my <a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">post</a> the other day.</p>

<p>I talked about how specifying little-endian would force big-endian browser vendors to choose one implementation strategy&#8212;emulate little-endian by byte-swapping and try to optimize as best they can&#8212;and concluded that it was better to let them decide for themselves and see how the market shakes out before specifying. But that doesn&#8217;t take into account the cost to web developers, which should always be the first priority (mea culpa).</p>

<p>Leaving it unspecified or forcing developers to opt in to a specified endianness taxes developers: it leaves them open to the possibility of their sites breaking on systems they likely can&#8217;t even test on, or forces them to make sure they pass the argument (in which case, they&#8217;d always be one forgotten argument away from possible bustage on some platform they can&#8217;t test on).</p>

<p>Imagine that instead of defaulting to unspecified behavior, we defaulted to little-endian&#8212;which is the de facto semantics of the web today&#8212;but apps could opt in to big-endian with an optional argument. Then a carefully-written app could use this (in combination with, say, a <code>navigator.endianness</code> feature test API) to decide which byte order would give them better performance. On little-endian systems, they&#8217;d use little-endian, on big-endian systems, they&#8217;d use big-endian. Less carefully-written apps that just went with the default might get some performance degradation in big-endian platforms, but we don&#8217;t actually know how bad it would be. But crucially, <strong>there would be no way to accidentally break your app&#8217;s behavior</strong>.</p>

<p>But let me take it one step further. I don&#8217;t even think we know that that additional option will be needed. For now, we don&#8217;t even know of any big-endian user agents that are implementing WebGL, nor do we know if byte-swapping will be prohibitively expensive. Until then, I say any additional API surface area is premature optimization. <a href="http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it">YAGNI</a>.</p>

<p>In summary: let&#8217;s prioritize web developers over hypothetical performance issues on hypothetical browsers. <strong>Typed arrays should be standardized as little-endian</strong>&#8212;full stop.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The little-endian web?]]></title>
    <link href="http://calculist.org/blog/2012/04/24/the-little-endian-web/"/>
    <updated>2012-04-24T22:32:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/24/the-little-endian-web</id>
    <content type="html"><![CDATA[<p>Here&#8217;s the deal: <a href="http://www.khronos.org/registry/typedarray/specs/latest/">typed arrays</a> are not fully portable. On most browsers, this code will print 1:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">a1</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>But the typed arrays spec doesn&#8217;t specify a byte order. So a browser on a big-endian system (say, a PowerPC console like Xbox or PS3) is allowed to print 0. In short: <strong>casting an <code>ArrayBuffer</code> to different types is unportable by default.</strong> It&#8217;s up to web developers to canonicalize bytes for different architectures.</p>

<p><img class="right" src="http://calculist.org/images/nuxi.jpg"></p>

<p>Now, we could just require typed arrays to be little-endian, once and for all. After all, almost all platforms are little-endian these days. The few big-endian platforms could just automatically reorder bytes for all typed array accesses. But this would have to be made to work with WebGL, which works by sending application-generated buffers to the GPU. In order to make this work on a big-endian architecture, little-endian-encoded <code>ArrayBuffer</code> data would need to be translated when sending back and forth to the GPU. Technically, <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-March/035236.html">this might be possible</a>, but there&#8217;s really no evidence that it would have acceptable performance.</p>

<p>On the other hand, can we really trust that web applications will write portable code? Imagine a <a href="http://blog.faultylabs.com/files/md5.js">hashing algorithm</a> that builds an internal <code>ArrayBuffer</code> and casts it to different types. If the code isn&#8217;t written portably, it&#8217;ll break on a browser implementing big-endian typed arrays.</p>

<p>This leaves big-endian browsers with a <strong>nasty decision</strong>: try to emulate little-endian typed arrays to protect against unportable application logic, and suffer the complexity and performance costs of translating data back and forth to the GPU, or just hope that not too many web pages break. Or perhaps surface an annoying decision to users: do you want to run this application in fast mode or correct mode?</p>

<p>For now, we should let browser vendors on big-endian systems make that decision, and not force the decision through the spec. If they end up all choosing to emulate little-endian, I&#8217;ll be happy to codify that in the standards. As I understand it, <a href="http://www.floodgap.com/software/tenfourfox/">TenFourFox</a> can&#8217;t support WebGL, so there the best decision is probably to emulate little-endianness. On an Xbox, I would guess WebGL performance would be a higher priority than web sites using internal <code>ArrayBuffer</code>s. But I&#8217;m not sure. I&#8217;d say this is a decision for big-endian browsers to make, but <strong>I would greatly welcome their input</strong>.</p>

<p>In the meantime, we should do everything we can to make portability more attractive and convenient. For working with I/O, where you need explicit control over endianness, applications can use <a href="https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView">DataView</a>. For heterogeneous data, there&#8217;ll be ES6 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:binary_data">structs</a>. Finally, I&#8217;d like to add an option for <code>ArrayBuffer</code>s and typed arrays to be given an optional explicit endianness:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="s2">&quot;little&quot;</span><span class="p">);</span> <span class="c1">// a little-endian buffer</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// must be 1, regardless of system architecture</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the endianness specified explicitly, you can still easily write portable logic even when casting&#8212;without having to canonicalize bytes yourself. <a href="https://github.com/kripken/emscripten">Emscripten</a> and <a href="http://www.mandreel.com/">Mandreel</a> could benefit from this increased portability, for example, and I think crypto algorithms would as well. I&#8217;ll propose this extension to Khronos and TC39, and discuss it with JavaScript engine implementors.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homoiconicity isn't the point]]></title>
    <link href="http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/"/>
    <updated>2012-04-17T07:51:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point</id>
    <content type="html"><![CDATA[<p>I&#8217;ve never really understood what &#8220;homoiconic&#8221; is supposed to mean. People often say something like &#8220;the syntax uses one of the language&#8217;s basic data structures.&#8221; That&#8217;s a category error: syntax is not a data structure, it&#8217;s just a representation of data as text. Or you hear &#8220;<a href="http://smallcultfollowing.com/babysteps/blog/2012/04/15/syntax-matters-dot-dot-dot/">the syntax of the language is the same as the syntax of its data structures</a>.&#8221; But S-expressions don&#8217;t &#8220;belong&#8221; to Lisp; there&#8217;s no reason why Perl or Haskell or JavaScript couldn&#8217;t have S-expression libraries. And every parser generates a data structure, so if you have a <a href="http://docs.python.org/library/parser.html">Python parser in Python</a>, then is Python homoiconic? Is <a href="http://esprima.org/">JavaScript</a>?</p>

<p>Maybe there&#8217;s a more precise way to define homoiconicity, but frankly I think it misses the point. What makes Lisp&#8217;s syntax powerful is not the fact that it can be represented as a data structure, it&#8217;s that <strong>it&#8217;s possible to <em>read</em> it without <em>parsing</em></strong>.</p>

<p>Wait, what?</p>

<p>It&#8217;s hard to explain these concepts with traditional terminology, because the distinction between reading and parsing simply doesn&#8217;t exist for languages without macros.</p>

<h3>Parsing vs reading: the compiler&#8217;s view</h3>

<p>In almost every non-Lispy language ever, the front end of every interpreter and compiler looks pretty much the same:</p>

<p><img class="center" src="http://calculist.org/images/parse-pipeline.png"></p>

<p>Take the text, run it through a parser, and you get out an AST. But that&#8217;s not how it works when you have macros. You simply can&#8217;t produce an AST without expanding macros first. So the front-end of a Lispy language usually looks more like:</p>

<p><img class="center" src="http://calculist.org/images/macro-pipeline.png"></p>

<p>What&#8217;s this intermediate syntax tree? It&#8217;s an almost entirely superficial understanding of your program: it basically does paren-matching to create a tree representing the surface nesting structure of the text. This is nowhere near an AST, but it&#8217;s just enough for the macro expansion system to do its job.</p>

<h3>Parsing vs reading: the macro expander&#8217;s view</h3>

<p>If you see this statement in the middle of a JavaScript program:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="nx">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">print</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>you know for sure that it&#8217;s a <em>ForInStatement</em>, as defined by the spec (I&#8217;m using <code>let</code> because&#8230; ES6, that&#8217;s why). If you know the grammar of JavaScript, you know the entire structure of the statement. But in Scheme, we could implement <code>for</code> as a macro. When the macro expander encounters:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">key</span> <span class="nv">obj</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>it knows nothing about the contents of the expression. All it knows is the macro definition of <code>for</code>. But that&#8217;s all it needs to know! The expander just takes the two subtrees, <code>(key obj)</code> and <code>(print key)</code>, and passes them as arguments to the <code>for</code> macro.</p>

<h3>Parsing vs reading: the macro&#8217;s view</h3>

<p>Here&#8217;s a simple <code>for</code> macro, written in <a href="http://docs.racket-lang.org/guide/pattern-macros.html#%28part._define-syntax-rule%29">Racket</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">define-syntax-rule</span> <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">e1</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span> <span class="nv">e1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This macro works by <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>: it expects two sub-trees, the first of which can itself be broken down into two identifier nodes <code>x</code> and <code>e1</code>, and it expands into the <code>for-each</code> expression. So when the expander calls the macro with the above example, the result of expansion is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">key</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span> <span class="nv">obj</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The power of the parenthesis</h3>

<p>If you&#8217;ve ever wondered why Lisp weirdos are so inexplicably attached to their parentheses, this is what it&#8217;s all about. Parentheses make it unambiguous for the expander to understand what the arguments to a macro are, because <strong>it&#8217;s always clear where the arguments begin and end</strong>. It knows this without needing to understand anything about what the macro definition is going to do. Imagine trying to define a macro expander for a language with syntax like JavaScript&#8217;s. What should the expander do when it sees:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">quux</span> <span class="p">(</span><span class="nx">mumble</span><span class="p">,</span> <span class="nx">flarg</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="nx">grunch</span> <span class="o">/</span><span class="nx">wibble</span><span class="o">/</span><span class="nx">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>How many arguments does <code>quux</code> take? Is the curly-braced argument a block statement or an object literal? Is the thing at the end an arithmetic expression or a regular expression literal? These are all questions that can&#8217;t be answered in JavaScript without knowing your parsing context&#8212;and macros obscure the parsing context.</p>

<p>None of this is to say that it&#8217;s <em>impossible</em> to design a macro system for languages with non-Lispy syntax. My point is just that the power of Lisp&#8217;s (Scheme&#8217;s, Racket&#8217;s, Clojure&#8217;s, &#8230;) macros comes not from being somehow tied to a central data structure of the language, but rather to the expander&#8217;s ability to break up a macro call into its separate arguments and then let the macro do all the work of parsing those arguments. In other words, <strong>homoiconicity isn&#8217;t the point, <code>read</code> is</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synchronous module loading in ES6]]></title>
    <link href="http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/"/>
    <updated>2012-03-29T07:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6</id>
    <content type="html"><![CDATA[<p>One of the great features of ES6 modules is the direct style module loading syntax:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">map</span> <span class="nx">from</span> <span class="s2">&quot;underscore.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>This makes it as frictionless as possible to grow or refactor your code into multiple modules, and to pull third-party modules into an existing codebase. It also makes a common module format that can be shared between the browser and JS servers like Node.</p>

<p>But this direct style requires loading its dependencies before it can execute. That is, it&#8217;s a synchronous module load. Put in the context of a <code>script</code> tag, this would make it all too easy to block page rendering on I/O:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="right" src="http://calculist.org/images/boromir-sync.jpg"> Throwing this syntax into the browser like this would be an <a href="https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Synchronous_and_asynchronous_requests">invitation to jank</a>. Thanks to insight from <a href="http://blogs.msdn.com/b/lukeh">Luke Hoban</a>, I think we have the right approach to this for ES6, which is in fact similar to our approach to avoiding turning <code>eval</code> into a synchronous I/O operation.</p>

<p>In previous versions of ECMAScript, there&#8217;s only one syntactic category of program that you can evaluate, called <code>Program</code> in the grammar. In ES6, we&#8217;ll define a restricted version of the syntax to be used in synchronous settings, which makes it illegal to do synchronous loads. Within a blocking script, the only access to modules is via the dynamic loading API:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="nx">System</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;jquery.js&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This eliminates the footgun, and all of your modules can themselves use the synchronous loading syntax. For example, if <code>jquery.js</code> wants to use a module&#8212;say, a data structure library&#8212;it can go ahead and load it synchronously:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// jquery.js</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">Stack</span> <span class="nx">from</span> <span class="s2">&quot;utils.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>But still, this restriction on the top-level loses the convenience of directly importing modules from scripts. Thing is, in an asynchronous context, there&#8217;s nothing wrong with doing a synchronous load. So just like the asynchronously loaded <code>jquery.js</code> can use the synchronous syntax, we can also allow it in a <code>defer</code> or <code>async</code> script:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script </span><span class="na">async</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows the full flexibility and expressiveness of ES6 embedded in HTML, without any hazard of blocking page rendering for I/O.</p>

<p>The <code>eval</code> function for ES6 will work the same way, disallowing synchronous loading syntax in the grammar it recognizes, to prevent turning it into a synchronous API. We&#8217;ll also add an asynchronous version of <code>eval</code> that, like <code>script async</code>, recognizes the full grammar.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two years at MoCo]]></title>
    <link href="http://calculist.org/blog/2012/01/10/two-years-at-moco/"/>
    <updated>2012-01-10T08:13:00-08:00</updated>
    <id>http://calculist.org/blog/2012/01/10/two-years-at-moco</id>
    <content type="html"><![CDATA[<p>If I remember right, today is my two year anniversary working full time at Mozilla. And it works out to about six years of working with Mozilla and <a href="http://www.ecma-international.org/memento/TC39.htm">TC39</a>. I could stop and get sentimental, but <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals">there&#8217;s work to do</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why coroutines won't work on the web]]></title>
    <link href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/"/>
    <updated>2011-12-14T10:30:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://calculist.org/images/yunocoros.jpg"> The topic of coroutines (or
fibers, or continuations) for JavaScript comes up from time to time,
so I figured I&#8217;d write down my thoughts on the matter. I admit to
having a soft spot for crazy control-flow features like continuations,
but they&#8217;re unlikely ever to make it into ECMAScript. With good
reason.</p>

<p>The big justification for coroutines in JavaScript is non-blocking
I/O. As we all know, asynchronous I/O leads to callback API&#8217;s, which
lead to nested lambdas, which lead to&#8230; the pyramid of doom:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">range</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;preheat&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">pot</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;boil&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">rice</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;cooked&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">dinner</span><span class="p">.</span><span class="nx">serve</span><span class="p">(</span><span class="nx">rice</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>Whereas, if you look at the README for
<a href="https://github.com/laverdet/node-fibers">node-fibers</a>, you&#8217;ll see
this pleasant-looking example:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>That looks pretty sweet. It&#8217;s a synchronous version of <code>setTimeout</code>
that doesn&#8217;t block the main thread. This seems like a nice combination
of the sequential style of synchronous code but with the
responsiveness of non-blocking I/O. Why wouldn&#8217;t we want something
like this in ECMAScript?</p>

<h2>Coroutines are almost as pre-emptive as threads</h2>

<p>Part of the beauty of JavaScript&#8217;s event loop is that there&#8217;s a very
clear synchronization point for reaching a stable state in your
programs: the end of the current turn. You can go ahead and leave
things in a funky intermediate state for as long as you like, and as
long as you stitch everything back up in time for the next spin of the
event loop, no other code can run in the meantime. That means you can
be sure that while your object is lying in pieces on the floor, nobody
else can poke at it before you put it back together again.</p>

<p>Once you add coroutines, you never know when someone might call
<code>yield</code>.  Any function you call has the right to pause and resume you
whenever they want, <em>even after any number of spins of the event
loop</em>. Now any time you find yourself modifying state, you start
worrying that calling a function might interrupt some code you
intended to be transactional. Take something as simple as swapping a
couple fields of an object:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="nx">munge</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>What happens if <code>munge</code> does a <code>yield</code> and only resumes your code
after a few other events fire? Those events could interact with <code>obj</code>,
and they&#8217;d see it in this intermediate state where both <code>obj.foo</code> and
<code>obj.bar</code> are the same value, because <code>obj.bar</code> hasn&#8217;t yet been
updated.</p>

<p>We&#8217;ve seen this movie before. This is just like Java&#8217;s threads, where
any time you&#8217;re working with state, you have to worry about who might
try to touch your data before it reaches a stable point. To be fair,
life is actually far worse in Java, where almost every single basic
operation of the language can be pre-empted. But still, with
coroutines, every function call becomes a potential pre-emption point.</p>

<h2>Host frames make coroutines unportable</h2>

<p>And then there&#8217;s the implementation problem. Unless your JavaScript
engine doesn&#8217;t use a stack (and they all do), coroutines would have to
be able to save a stack on the heap and restore it back on the stack
later. But what if JavaScript code calls into code implemented in the
host language (usually C++)? Some engines implement functions like
<code>Array.prototype.forEach</code> in C++. How would they handle code like
this?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">array</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>Other languages with coroutines take different approaches.  Lua allows
implementations to <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield">throw an error</a>
if user code tries to suspend host activations. This would simply be
unportable, since different engines would implement different standard
libraries in C++.</p>

<p>The Scheme community tends to demand a lot from their continuations,
so they expect functions like <code>for-each</code> and <code>map</code> to be
suspended. This could mean either forcing all the standard libraries
to be self-hosted, or using more complicated <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.9076">implementation strategies</a>
than traditional stacks.</p>

<p>Simply put: browser vendors are not going to do this. Modern JS
engines are extraordinary feats of engineering, and rearchitecting
their entire stack mechanism is just not realistic. Then when you
consider that these changes could hurt performance of ordinary
function calls, well&#8230; end of discussion.</p>

<h2>Shallow coroutines to the rescue</h2>

<p>OK, back to the pyramid of doom. It really does kind of suck. I mean,
you could name and lift out your functions, but then you break up the
sequential flow even worse, and you get a combinatorial explosion of
function arguments for all those upvars.</p>

<p>This is why I&#8217;m excited about
<a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>. Generators
are a lot like coroutines, with one important difference: <em>they only
suspend their own function activation</em>. In ES6, <code>yield</code> isn&#8217;t a
function that anyone can use, it&#8217;s a built-in operator that only a
generator function can use. With generators, calling a JS function is
as benign as it ever was. You never have to worry that a function call
might <code>yield</code> and stop you from doing what you were trying to do.</p>

<p>But it&#8217;s still possible to build an API similar to node-fibers. This
is the idea of <a href="https://github.com/dherman/taskjs">task.js</a>. The
fibers example looks pretty similar in task.js:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Task</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">yield</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="p">}).</span><span class="nx">run</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>The big difference is that the <code>sleep</code> function doesn&#8217;t <em>implicitly</em>
yield; instead, it returns a
<a href="http://blogs.msdn.com/b/ie/archive/2011/09/11/asynchronous-programming-in-javascript-with-promises.aspx">promise</a>. The
task then <em>explicitly</em> <code>yield</code>s the promise back to the task.js
scheduler. When the promise is fulfilled, the scheduler wakes the task
back up to continue. Hardly any wordier than node-fibers, but with the
benefit that you can always tell when and what you&#8217;re suspending.</p>

<h2>Coroutines no, generators yes</h2>

<p>Coroutines are not going to happen in JavaScript. They would break one
of the best features of JavaScript: the simplicity of the event loop
execution model. And the demands they would place on current engines
for portability are simply unrealistic. But generator functions are
easy to add to existing engines, they have none of the portability
issues of coroutines, and they give you just enough power to write
non-blocking I/O in a synchronous style without being &#8220;threads lite.&#8221;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Obligatory fawning over Octopress]]></title>
    <link href="http://calculist.org/blog/2011/12/05/obligatory-fawning-over-octopress/"/>
    <updated>2011-12-05T21:14:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/05/obligatory-fawning-over-octopress</id>
    <content type="html"><![CDATA[<p>I&#8217;m joining the throngs of programmer-bloggers using <a href="http://octopress.org">Octopress</a> for my new blog.
There&#8217;s so much to commend about it, but it really comes down to one thing:</p>

<p><em>Programmers should be able to write their blogs in text editors.</em></p>

<p>Also, from now on, everything I ever do in my life should be in GitHub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, world]]></title>
    <link href="http://calculist.org/blog/2011/12/05/hello/"/>
    <updated>2011-12-05T16:00:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/05/hello</id>
    <content type="html"><![CDATA[<p>This is my blog&#8217;s new home.</p>

<p>My old blogs:</p>

<ul>
<li><a href="http://calculist.blogspot.com">http://calculist.blogspot.com</a></li>
<li><a href="http://blog.mozilla.com/dherman">http://blog.mozilla.com/dherman</a></li>
</ul>


<p>should stick around indefinitely as archives but they&#8217;ll be inactive from now on.</p>
]]></content>
  </entry>
  
</feed>
