<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Little Calculist]]></title>
  <link href="http://calculist.org/atom.xml" rel="self"/>
  <link href="http://calculist.org/"/>
  <updated>2012-07-03T12:08:02-07:00</updated>
  <id>http://calculist.org/</id>
  <author>
    <name><![CDATA[Dave Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tweaking the JavaScript AST API]]></title>
    <link href="http://calculist.org/blog/2012/07/03/tweaking-the-javascript-ast-api/"/>
    <updated>2012-07-03T11:53:00-07:00</updated>
    <id>http://calculist.org/blog/2012/07/03/tweaking-the-javascript-ast-api</id>
    <content type="html"><![CDATA[<p>A couple years ago I created a <a href="https://developer.mozilla.org/en/SpiderMonkey/Parser_API">JavaScript parser API</a> and implemented SpiderMonkey&#8217;s <a href="https://developer.mozilla.org/en/SpiderMonkey/Parser_API#Reflect.parse%28src.5B.2C_options.5D%29">Reflect.parse</a> library. Since then, there have been a couple of pure JavaScript implementations of the API, including Zach Carter&#8217;s <a href="https://github.com/zaach/reflect.js">reflect.js</a> and Ariya Hidayat&#8217;s <a href="http://esprima.org">Esprima</a> parser.</p>

<p>Over time, I&#8217;ve gotten a bunch of good critiques about the API from people. I probably don&#8217;t want to make any huge changes, but there are a couple of small changes that would be nice:</p>

<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=770567">Bug 770567</a> - rename <code>callee</code> to <code>constructor</code> to match the documentation</li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=742612">Bug 742612</a> - separate guarded/unguarded catch clauses</li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678">Bug 745678</a> - range-based location info</li>
</ul>


<p>Ariya is graciously willing to change Esprima to keep in sync with SpiderMonkey. But some of these would affect existing clients of either library. I wanted to post this publicly to ask if there&#8217;s anyone who would be opposed to us making the change. Ariya and I would make sure to be very clear about when we&#8217;re making the change, and we&#8217;d try to batch the changes so that people don&#8217;t have to keep repeatedly updating their code.</p>

<p>Feel free to leave a comment if you are using Esprima or <code>Reflect.parse</code> and have thoughts about this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Static module resolution]]></title>
    <link href="http://calculist.org/blog/2012/06/29/static-module-resolution/"/>
    <updated>2012-06-29T13:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/06/29/static-module-resolution</id>
    <content type="html"><![CDATA[<p>I haven&#8217;t spoken enough about the rationale for declarative, static module resolution in <a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">ES6 modules</a>. Since multiple module systems exist in pure JS, the concept of modules that involve new syntax is coming across as foreign to people. I&#8217;d like to explain the motivation.</p>

<p>First, a quick explanation of what this is about. In a pure-JS system like CommonJS, modules are just objects, and whatever definitions they export can be imported by a client with object property lookup:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>By contrast, in the ES6 module system, modules are not objects, they&#8217;re declarative collections of code. Importing definitions from a module is also declarative:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="p">{</span> <span class="nx">stat</span><span class="p">,</span> <span class="nx">exists</span><span class="p">,</span> <span class="nx">readFile</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;fs&#39;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This import is resolved at compile time&#8212;that is, before the script starts executing. All the imports and exports of the declarative module dependency graph are resolved before execution. (There&#8217;s also an asynchronous dynamic loading API; it&#8217;s of course important to be able to defer module loading to runtime. But this post is about the resolution of a declarative module dependency graph.)</p>

<h2>On the origin of specs</h2>

<p><img class="right" src="http://calculist.org/images/evolution.jpg"></p>

<p>Node leaders are arguing that we should take more incremental, evolutionary steps, that we should hew more closely to the module systems that exist today. I have a lot of sympathy for the &#8220;pave the cowpaths&#8221; philosophy, and I often argue for it. But the module systems people have built for JavaScript to date did not have the option of modifying the language. We have an opportunity to move JS in directions where a purely dynamic system could never go.</p>

<p>What are some of those directions?</p>

<h2>Fast lookup</h2>

<p>Static imports (whether via <code>import</code> or references like <code>m.foo</code>) can always be compiled like variable references. In a dynamic module system, an explicit dereference like <code>m.foo</code> will be an object reference, which will generally require <a href="http://blog.cdleary.com/2010/09/picing-on-javascript-for-fun-and-profit/">PIC guards</a>. If you copy them into locals, they&#8217;ll be more optimizable in some cases, but with static modules you always predictably get early binding. Keeping module references as cheap as variable references makes modular programs faster and avoids imposing a tax on modular code.</p>

<h2>Early variable checking</h2>

<p>Having variable references, including imports and exports, checked before a script starts running is, in my experience, very useful for making sure the basic top-level structure of a program is sane. JavaScript is almost statically scoped, and this is our one and only chance to get there. James Burke dismisses this as a kind of <a href="http://tagneto.blogspot.ca/2012/06/es-modules-suggestions-for-improvement.html">shallow type checking</a>, which he claims is not enough to be useful. My experience in other languages says otherwise — it is super useful! Variable checking is a nice sweet spot where you can still write expressive dynamic programs, but catch really basic and common errors. As Anton Kovalyov points out, unbound variable reporting is a <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-June/023777.html">popular feature in JSHint</a>, and it&#8217;s so much nicer not to have to run a separate linter to catch these bugs.</p>

<h2>Cyclic dependencies</h2>

<p>Allowing cyclic dependencies between modules is really important. Mutual recursion is a fact of programming. It occurs sometimes without you even noticing it. If you try splitting up your program into modules and the system breaks because it can&#8217;t handle cycles, the easiest workaround is just to keep everything together in one big module. Module systems should not prevent programmers from splitting up their program however they see fit. They should not provide disincentives from writing modular programs.</p>

<p>This isn&#8217;t impossible with dynamic systems, but it tends to be something I see treated as an afterthought by alternative proposals. It&#8217;s something we&#8217;ve thought very carefully about for ES6. Also, declarative modules allow you to pre-initialize more of the module structure before executing any code, so that you can give better errors if someone refers to a not-yet-assigned export. For example, a <code>let</code> binding throws if you refer to it before it&#8217;s been assigned, and you get a clear error message. This is much easier to diagnose than referring to a property of a dynamic module object that just isn&#8217;t even there yet, getting <code>undefined</code>, and having to trace the eventual error back to the source.</p>

<h2>Future-compatibility for macros</h2>

<p>One of the things I would love to see in JavaScript&#8217;s future is the ability for programmers to come up with their own custom syntax extensions without having to wait for TC39 to add it. Today, people invent new syntax by writing their own compilers. But this is extremely hard to do, and you can&#8217;t use different syntax features from different compilers in a single source file.</p>

<p>With macros, you might implement, say, a new <code>cond</code> syntax that makes a nicer alternative to chaining <code>? :</code> conditionals, and share that via a library:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">cond</span> <span class="nx">from</span> <span class="s1">&#39;cond.js&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">cond</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span><span class="o">:</span> <span class="s2">&quot;null&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">case</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="o">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s2">&quot;object&quot;</span><span class="p">)</span><span class="o">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span> <span class="k">typeof</span> <span class="nx">x</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>cond</code> macro would preprocess this into a chain of conditionals before the program runs. Preprocessing doesn&#8217;t work with purely dynamic modules:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">cond</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;cond.js&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// impossible to preprocess because we haven&#39;t evaluated the require!</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">cond</span> <span class="p">{</span> <span class="cm">/* etc */</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Future-compatibility for types</h2>

<p>I joined TC39 in the ill-fated ES4 days, when the committee was working on an optional type system for JS. It was built on sketchy foundations and ultimately fell apart. One of the things that was really lacking was a module system where you could draw a boundary around a section of code and say &#8220;this part needs to be type-checked.&#8221; Otherwise you never knew if more code was going to be appended later.</p>

<p>Why types? Here&#8217;s one reason: JS is fast and getting faster, but it only gets <a href="http://blog.mrale.ph/post/12396216081/the-trap-of-the-performance-sweet-spot">harder to predict performance</a>. With experiments like <a href="http://lljs.org">LLJS</a>, my group at Mozilla is playing with dialects of JS that use types to pre-compile offline and generate some pretty funky JS code optimized for current JIT&#8217;s. But if you could just directly write your high-performance kernels in a typed dialect of JS, modern compilers could go to town with it.</p>

<p>With declarative resolution, you can import and export typed definitions and they can all be checked at compile-time. Dynamic imports can&#8217;t be statically checked.</p>

<h2>Inter-language modularity</h2>

<p>Some people may not care about or want features like macros or types. But JavaScript has to serve many different programmers who come with many different development practices and needs. And one of the ways it can do so is by allowing people to use their own languages that compile to JavaScript. So even if macros or types aren&#8217;t in the future of the ECMAScript standard, it&#8217;d be pretty great if you could use statically typed or macro-enabled dialects of JS offline that compile to browser-compatible JS. People are already doing this kind of thing today with the <a href="https://developers.google.com/closure/compiler/">Closure compiler</a>&#8217;s type checking, or the <a href="http://roy.brianmckenna.org/">Roy</a> language, or <a href="https://github.com/clojure/clojurescript">ClojureScript</a>. A static module system is more universally and straightforwardly compatible with a wider range of languages.</p>

<h2>Costs and benefits</h2>

<p>The above are some of the benefits that I see to declarative module resolution. Isaac Schlueter says the <code>import</code> syntax <a href="http://blog.izs.me/post/25906678790/on-es-6-modules">adds nothing</a>. That&#8217;s unfair and wrong. It&#8217;s there for a purpose. I don&#8217;t believe that a declarative import syntax is a high cost for the benefit both to ES6 and to potential future editions.</p>

<h2>PS: What&#8217;s all this about Python?</h2>

<p>One last thing: people keep claiming that the ES6 module system came from Python. I don&#8217;t even have very much experience with Python. And Python&#8217;s modules are more mutable and their scope is more dynamic. Personally, I&#8217;ve drawn inspiration from <a href="http://racket-lang.org">Racket</a>, which has gotten lots of mileage out of its <a href="http://docs.racket-lang.org/guide/Module_Syntax.html">declarative module system</a>. They&#8217;ve leveraged static modules to build a macro system, early variable checking, optimized references, dynamic contracts with module-based blame reporting, multi-language interoperability, and a statically typed dialect.</p>

<p>I&#8217;m not interested in making JavaScript into some other language. But you can learn a lot from studying precedent in other languages. I&#8217;ve seen firsthand the benefits you can get from a declarative module system in a dynamic language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The little-endian web!]]></title>
    <link href="http://calculist.org/blog/2012/04/25/the-little-endian-web/"/>
    <updated>2012-04-25T12:29:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/25/the-little-endian-web</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/The_Gates_of_Hell"><img class="right" src="http://calculist.org/images/gates-of-hell.jpg"></a></p>

<blockquote><p><a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">This</a> feels a little bit like the web platform having opened a door to hell and Zombies running out of it. I wonder if we can ever close it again.
&#8211; <a href="https://plus.google.com/u/1/116910304844117268718/posts/9fdegEJkAtt">Malte Ubl</a></p></blockquote>

<p>Let&#8217;s see if we can. I&#8217;ve had a bunch of productive conversations since my <a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">post</a> the other day.</p>

<p>I talked about how specifying little-endian would force big-endian browser vendors to choose one implementation strategy&#8212;emulate little-endian by byte-swapping and try to optimize as best they can&#8212;and concluded that it was better to let them decide for themselves and see how the market shakes out before specifying. But that doesn&#8217;t take into account the cost to web developers, which should always be the first priority (mea culpa).</p>

<p>Leaving it unspecified or forcing developers to opt in to a specified endianness taxes developers: it leaves them open to the possibility of their sites breaking on systems they likely can&#8217;t even test on, or forces them to make sure they pass the argument (in which case, they&#8217;d always be one forgotten argument away from possible bustage on some platform they can&#8217;t test on).</p>

<p>Imagine that instead of defaulting to unspecified behavior, we defaulted to little-endian&#8212;which is the de facto semantics of the web today&#8212;but apps could opt in to big-endian with an optional argument. Then a carefully-written app could use this (in combination with, say, a <code>navigator.endianness</code> feature test API) to decide which byte order would give them better performance. On little-endian systems, they&#8217;d use little-endian, on big-endian systems, they&#8217;d use big-endian. Less carefully-written apps that just went with the default might get some performance degradation in big-endian platforms, but we don&#8217;t actually know how bad it would be. But crucially, <strong>there would be no way to accidentally break your app&#8217;s behavior</strong>.</p>

<p>But let me take it one step further. I don&#8217;t even think we know that that additional option will be needed. For now, we don&#8217;t even know of any big-endian user agents that are implementing WebGL, nor do we know if byte-swapping will be prohibitively expensive. Until then, I say any additional API surface area is premature optimization. <a href="http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it">YAGNI</a>.</p>

<p>In summary: let&#8217;s prioritize web developers over hypothetical performance issues on hypothetical browsers. <strong>Typed arrays should be standardized as little-endian</strong>&#8212;full stop.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The little-endian web?]]></title>
    <link href="http://calculist.org/blog/2012/04/24/the-little-endian-web/"/>
    <updated>2012-04-24T22:32:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/24/the-little-endian-web</id>
    <content type="html"><![CDATA[<p>Here&#8217;s the deal: <a href="http://www.khronos.org/registry/typedarray/specs/latest/">typed arrays</a> are not fully portable. On most browsers, this code will print 1:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">a1</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>But the typed arrays spec doesn&#8217;t specify a byte order. So a browser on a big-endian system (say, a PowerPC console like Xbox or PS3) is allowed to print 0. In short: <strong>casting an <code>ArrayBuffer</code> to different types is unportable by default.</strong> It&#8217;s up to web developers to canonicalize bytes for different architectures.</p>

<p><img class="right" src="http://calculist.org/images/nuxi.jpg"></p>

<p>Now, we could just require typed arrays to be little-endian, once and for all. After all, almost all platforms are little-endian these days. The few big-endian platforms could just automatically reorder bytes for all typed array accesses. But this would have to be made to work with WebGL, which works by sending application-generated buffers to the GPU. In order to make this work on a big-endian architecture, little-endian-encoded <code>ArrayBuffer</code> data would need to be translated when sending back and forth to the GPU. Technically, <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-March/035236.html">this might be possible</a>, but there&#8217;s really no evidence that it would have acceptable performance.</p>

<p>On the other hand, can we really trust that web applications will write portable code? Imagine a <a href="http://blog.faultylabs.com/files/md5.js">hashing algorithm</a> that builds an internal <code>ArrayBuffer</code> and casts it to different types. If the code isn&#8217;t written portably, it&#8217;ll break on a browser implementing big-endian typed arrays.</p>

<p>This leaves big-endian browsers with a <strong>nasty decision</strong>: try to emulate little-endian typed arrays to protect against unportable application logic, and suffer the complexity and performance costs of translating data back and forth to the GPU, or just hope that not too many web pages break. Or perhaps surface an annoying decision to users: do you want to run this application in fast mode or correct mode?</p>

<p>For now, we should let browser vendors on big-endian systems make that decision, and not force the decision through the spec. If they end up all choosing to emulate little-endian, I&#8217;ll be happy to codify that in the standards. As I understand it, <a href="http://www.floodgap.com/software/tenfourfox/">TenFourFox</a> can&#8217;t support WebGL, so there the best decision is probably to emulate little-endianness. On an Xbox, I would guess WebGL performance would be a higher priority than web sites using internal <code>ArrayBuffer</code>s. But I&#8217;m not sure. I&#8217;d say this is a decision for big-endian browsers to make, but <strong>I would greatly welcome their input</strong>.</p>

<p>In the meantime, we should do everything we can to make portability more attractive and convenient. For working with I/O, where you need explicit control over endianness, applications can use <a href="https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView">DataView</a>. For heterogeneous data, there&#8217;ll be ES6 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:binary_data">structs</a>. Finally, I&#8217;d like to add an option for <code>ArrayBuffer</code>s and typed arrays to be given an optional explicit endianness:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="s2">&quot;little&quot;</span><span class="p">);</span> <span class="c1">// a little-endian buffer</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// must be 1, regardless of system architecture</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the endianness specified explicitly, you can still easily write portable logic even when casting&#8212;without having to canonicalize bytes yourself. <a href="https://github.com/kripken/emscripten">Emscripten</a> and <a href="http://www.mandreel.com/">Mandreel</a> could benefit from this increased portability, for example, and I think crypto algorithms would as well. I&#8217;ll propose this extension to Khronos and TC39, and discuss it with JavaScript engine implementors.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homoiconicity isn't the point]]></title>
    <link href="http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/"/>
    <updated>2012-04-17T07:51:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point</id>
    <content type="html"><![CDATA[<p>I&#8217;ve never really understood what &#8220;homoiconic&#8221; is supposed to mean. People often say something like &#8220;the syntax uses one of the language&#8217;s basic data structures.&#8221; That&#8217;s a category error: syntax is not a data structure, it&#8217;s just a representation of data as text. Or you hear &#8220;<a href="http://smallcultfollowing.com/babysteps/blog/2012/04/15/syntax-matters-dot-dot-dot/">the syntax of the language is the same as the syntax of its data structures</a>.&#8221; But S-expressions don&#8217;t &#8220;belong&#8221; to Lisp; there&#8217;s no reason why Perl or Haskell or JavaScript couldn&#8217;t have S-expression libraries. And every parser generates a data structure, so if you have a <a href="http://docs.python.org/library/parser.html">Python parser in Python</a>, then is Python homoiconic? Is <a href="http://esprima.org/">JavaScript</a>?</p>

<p>Maybe there&#8217;s a more precise way to define homoiconicity, but frankly I think it misses the point. What makes Lisp&#8217;s syntax powerful is not the fact that it can be represented as a data structure, it&#8217;s that <strong>it&#8217;s possible to <em>read</em> it without <em>parsing</em></strong>.</p>

<p>Wait, what?</p>

<p>It&#8217;s hard to explain these concepts with traditional terminology, because the distinction between reading and parsing simply doesn&#8217;t exist for languages without macros.</p>

<h3>Parsing vs reading: the compiler&#8217;s view</h3>

<p>In almost every non-Lispy language ever, the front end of every interpreter and compiler looks pretty much the same:</p>

<p><img class="center" src="http://calculist.org/images/parse-pipeline.png"></p>

<p>Take the text, run it through a parser, and you get out an AST. But that&#8217;s not how it works when you have macros. You simply can&#8217;t produce an AST without expanding macros first. So the front-end of a Lispy language usually looks more like:</p>

<p><img class="center" src="http://calculist.org/images/macro-pipeline.png"></p>

<p>What&#8217;s this intermediate syntax tree? It&#8217;s an almost entirely superficial understanding of your program: it basically does paren-matching to create a tree representing the surface nesting structure of the text. This is nowhere near an AST, but it&#8217;s just enough for the macro expansion system to do its job.</p>

<h3>Parsing vs reading: the macro expander&#8217;s view</h3>

<p>If you see this statement in the middle of a JavaScript program:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="nx">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">print</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>you know for sure that it&#8217;s a <em>ForInStatement</em>, as defined by the spec (I&#8217;m using <code>let</code> because&#8230; ES6, that&#8217;s why). If you know the grammar of JavaScript, you know the entire structure of the statement. But in Scheme, we could implement <code>for</code> as a macro. When the macro expander encounters:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">key</span> <span class="nv">obj</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>it knows nothing about the contents of the expression. All it knows is the macro definition of <code>for</code>. But that&#8217;s all it needs to know! The expander just takes the two subtrees, <code>(key obj)</code> and <code>(print key)</code>, and passes them as arguments to the <code>for</code> macro.</p>

<h3>Parsing vs reading: the macro&#8217;s view</h3>

<p>Here&#8217;s a simple <code>for</code> macro, written in <a href="http://docs.racket-lang.org/guide/pattern-macros.html#%28part._define-syntax-rule%29">Racket</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">define-syntax-rule</span> <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">e1</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span> <span class="nv">e1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This macro works by <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>: it expects two sub-trees, the first of which can itself be broken down into two identifier nodes <code>x</code> and <code>e1</code>, and it expands into the <code>for-each</code> expression. So when the expander calls the macro with the above example, the result of expansion is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">key</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span> <span class="nv">obj</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The power of the parenthesis</h3>

<p>If you&#8217;ve ever wondered why Lisp weirdos are so inexplicably attached to their parentheses, this is what it&#8217;s all about. Parentheses make it unambiguous for the expander to understand what the arguments to a macro are, because <strong>it&#8217;s always clear where the arguments begin and end</strong>. It knows this without needing to understand anything about what the macro definition is going to do. Imagine trying to define a macro expander for a language with syntax like JavaScript&#8217;s. What should the expander do when it sees:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">quux</span> <span class="p">(</span><span class="nx">mumble</span><span class="p">,</span> <span class="nx">flarg</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="nx">grunch</span> <span class="o">/</span><span class="nx">wibble</span><span class="o">/</span><span class="nx">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>How many arguments does <code>quux</code> take? Is the curly-braced argument a block statement or an object literal? Is the thing at the end an arithmetic expression or a regular expression literal? These are all questions that can&#8217;t be answered in JavaScript without knowing your parsing context&#8212;and macros obscure the parsing context.</p>

<p>None of this is to say that it&#8217;s <em>impossible</em> to design a macro system for languages with non-Lispy syntax. My point is just that the power of Lisp&#8217;s (Scheme&#8217;s, Racket&#8217;s, Clojure&#8217;s, &#8230;) macros comes not from being somehow tied to a central data structure of the language, but rather to the expander&#8217;s ability to break up a macro call into its separate arguments and then let the macro do all the work of parsing those arguments. In other words, <strong>homoiconicity isn&#8217;t the point, <code>read</code> is</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synchronous module loading in ES6]]></title>
    <link href="http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/"/>
    <updated>2012-03-29T07:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6</id>
    <content type="html"><![CDATA[<p>One of the great features of ES6 modules is the direct style module loading syntax:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">map</span> <span class="nx">from</span> <span class="s2">&quot;underscore.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>This makes it as frictionless as possible to grow or refactor your code into multiple modules, and to pull third-party modules into an existing codebase. It also makes a common module format that can be shared between the browser and JS servers like Node.</p>

<p>But this direct style requires loading its dependencies before it can execute. That is, it&#8217;s a synchronous module load. Put in the context of a <code>script</code> tag, this would make it all too easy to block page rendering on I/O:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="right" src="http://calculist.org/images/boromir-sync.jpg"> Throwing this syntax into the browser like this would be an <a href="https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Synchronous_and_asynchronous_requests">invitation to jank</a>. Thanks to insight from <a href="http://blogs.msdn.com/b/lukeh">Luke Hoban</a>, I think we have the right approach to this for ES6, which is in fact similar to our approach to avoiding turning <code>eval</code> into a synchronous I/O operation.</p>

<p>In previous versions of ECMAScript, there&#8217;s only one syntactic category of program that you can evaluate, called <code>Program</code> in the grammar. In ES6, we&#8217;ll define a restricted version of the syntax to be used in synchronous settings, which makes it illegal to do synchronous loads. Within a blocking script, the only access to modules is via the dynamic loading API:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="nx">System</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;jquery.js&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This eliminates the footgun, and all of your modules can themselves use the synchronous loading syntax. For example, if <code>jquery.js</code> wants to use a module&#8212;say, a data structure library&#8212;it can go ahead and load it synchronously:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// jquery.js</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">Stack</span> <span class="nx">from</span> <span class="s2">&quot;utils.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>But still, this restriction on the top-level loses the convenience of directly importing modules from scripts. Thing is, in an asynchronous context, there&#8217;s nothing wrong with doing a synchronous load. So just like the asynchronously loaded <code>jquery.js</code> can use the synchronous syntax, we can also allow it in a <code>defer</code> or <code>async</code> script:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script </span><span class="na">async</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows the full flexibility and expressiveness of ES6 embedded in HTML, without any hazard of blocking page rendering for I/O.</p>

<p>The <code>eval</code> function for ES6 will work the same way, disallowing synchronous loading syntax in the grammar it recognizes, to prevent turning it into a synchronous API. We&#8217;ll also add an asynchronous version of <code>eval</code> that, like <code>script async</code>, recognizes the full grammar.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two years at MoCo]]></title>
    <link href="http://calculist.org/blog/2012/01/10/two-years-at-moco/"/>
    <updated>2012-01-10T08:13:00-08:00</updated>
    <id>http://calculist.org/blog/2012/01/10/two-years-at-moco</id>
    <content type="html"><![CDATA[<p>If I remember right, today is my two year anniversary working full time at Mozilla. And it works out to about six years of working with Mozilla and <a href="http://www.ecma-international.org/memento/TC39.htm">TC39</a>. I could stop and get sentimental, but <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals">there&#8217;s work to do</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why coroutines won't work on the web]]></title>
    <link href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/"/>
    <updated>2011-12-14T10:30:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web</id>
    <content type="html"><![CDATA[<p><img class="right" src="http://calculist.org/images/yunocoros.jpg"> The topic of coroutines (or
fibers, or continuations) for JavaScript comes up from time to time,
so I figured I&#8217;d write down my thoughts on the matter. I admit to
having a soft spot for crazy control-flow features like continuations,
but they&#8217;re unlikely ever to make it into ECMAScript. With good
reason.</p>

<p>The big justification for coroutines in JavaScript is non-blocking
I/O. As we all know, asynchronous I/O leads to callback API&#8217;s, which
lead to nested lambdas, which lead to&#8230; the pyramid of doom:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">range</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;preheat&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">pot</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;boil&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">rice</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;cooked&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">dinner</span><span class="p">.</span><span class="nx">serve</span><span class="p">(</span><span class="nx">rice</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>Whereas, if you look at the README for
<a href="https://github.com/laverdet/node-fibers">node-fibers</a>, you&#8217;ll see
this pleasant-looking example:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>That looks pretty sweet. It&#8217;s a synchronous version of <code>setTimeout</code>
that doesn&#8217;t block the main thread. This seems like a nice combination
of the sequential style of synchronous code but with the
responsiveness of non-blocking I/O. Why wouldn&#8217;t we want something
like this in ECMAScript?</p>

<h2>Coroutines are almost as pre-emptive as threads</h2>

<p>Part of the beauty of JavaScript&#8217;s event loop is that there&#8217;s a very
clear synchronization point for reaching a stable state in your
programs: the end of the current turn. You can go ahead and leave
things in a funky intermediate state for as long as you like, and as
long as you stitch everything back up in time for the next spin of the
event loop, no other code can run in the meantime. That means you can
be sure that while your object is lying in pieces on the floor, nobody
else can poke at it before you put it back together again.</p>

<p>Once you add coroutines, you never know when someone might call
<code>yield</code>.  Any function you call has the right to pause and resume you
whenever they want, <em>even after any number of spins of the event
loop</em>. Now any time you find yourself modifying state, you start
worrying that calling a function might interrupt some code you
intended to be transactional. Take something as simple as swapping a
couple fields of an object:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="nx">munge</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>What happens if <code>munge</code> does a <code>yield</code> and only resumes your code
after a few other events fire? Those events could interact with <code>obj</code>,
and they&#8217;d see it in this intermediate state where both <code>obj.foo</code> and
<code>obj.bar</code> are the same value, because <code>obj.bar</code> hasn&#8217;t yet been
updated.</p>

<p>We&#8217;ve seen this movie before. This is just like Java&#8217;s threads, where
any time you&#8217;re working with state, you have to worry about who might
try to touch your data before it reaches a stable point. To be fair,
life is actually far worse in Java, where almost every single basic
operation of the language can be pre-empted. But still, with
coroutines, every function call becomes a potential pre-emption point.</p>

<h2>Host frames make coroutines unportable</h2>

<p>And then there&#8217;s the implementation problem. Unless your JavaScript
engine doesn&#8217;t use a stack (and they all do), coroutines would have to
be able to save a stack on the heap and restore it back on the stack
later. But what if JavaScript code calls into code implemented in the
host language (usually C++)? Some engines implement functions like
<code>Array.prototype.forEach</code> in C++. How would they handle code like
this?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">array</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>Other languages with coroutines take different approaches.  Lua allows
implementations to <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield">throw an error</a>
if user code tries to suspend host activations. This would simply be
unportable, since different engines would implement different standard
libraries in C++.</p>

<p>The Scheme community tends to demand a lot from their continuations,
so they expect functions like <code>for-each</code> and <code>map</code> to be
suspended. This could mean either forcing all the standard libraries
to be self-hosted, or using more complicated <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.9076">implementation strategies</a>
than traditional stacks.</p>

<p>Simply put: browser vendors are not going to do this. Modern JS
engines are extraordinary feats of engineering, and rearchitecting
their entire stack mechanism is just not realistic. Then when you
consider that these changes could hurt performance of ordinary
function calls, well&#8230; end of discussion.</p>

<h2>Shallow coroutines to the rescue</h2>

<p>OK, back to the pyramid of doom. It really does kind of suck. I mean,
you could name and lift out your functions, but then you break up the
sequential flow even worse, and you get a combinatorial explosion of
function arguments for all those upvars.</p>

<p>This is why I&#8217;m excited about
<a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>. Generators
are a lot like coroutines, with one important difference: <em>they only
suspend their own function activation</em>. In ES6, <code>yield</code> isn&#8217;t a
function that anyone can use, it&#8217;s a built-in operator that only a
generator function can use. With generators, calling a JS function is
as benign as it ever was. You never have to worry that a function call
might <code>yield</code> and stop you from doing what you were trying to do.</p>

<p>But it&#8217;s still possible to build an API similar to node-fibers. This
is the idea of <a href="https://github.com/dherman/taskjs">task.js</a>. The
fibers example looks pretty similar in task.js:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Task</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">yield</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="p">}).</span><span class="nx">run</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>The big difference is that the <code>sleep</code> function doesn&#8217;t <em>implicitly</em>
yield; instead, it returns a
<a href="http://blogs.msdn.com/b/ie/archive/2011/09/11/asynchronous-programming-in-javascript-with-promises.aspx">promise</a>. The
task then <em>explicitly</em> <code>yield</code>s the promise back to the task.js
scheduler. When the promise is fulfilled, the scheduler wakes the task
back up to continue. Hardly any wordier than node-fibers, but with the
benefit that you can always tell when and what you&#8217;re suspending.</p>

<h2>Coroutines no, generators yes</h2>

<p>Coroutines are not going to happen in JavaScript. They would break one
of the best features of JavaScript: the simplicity of the event loop
execution model. And the demands they would place on current engines
for portability are simply unrealistic. But generator functions are
easy to add to existing engines, they have none of the portability
issues of coroutines, and they give you just enough power to write
non-blocking I/O in a synchronous style without being &#8220;threads lite.&#8221;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Obligatory fawning over Octopress]]></title>
    <link href="http://calculist.org/blog/2011/12/05/obligatory-fawning-over-octopress/"/>
    <updated>2011-12-05T21:14:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/05/obligatory-fawning-over-octopress</id>
    <content type="html"><![CDATA[<p>I&#8217;m joining the throngs of programmer-bloggers using <a href="http://octopress.org">Octopress</a> for my new blog.
There&#8217;s so much to commend about it, but it really comes down to one thing:</p>

<p><em>Programmers should be able to write their blogs in text editors.</em></p>

<p>Also, from now on, everything I ever do in my life should be in GitHub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, world]]></title>
    <link href="http://calculist.org/blog/2011/12/05/hello/"/>
    <updated>2011-12-05T16:00:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/05/hello</id>
    <content type="html"><![CDATA[<p>This is my blog&#8217;s new home.</p>

<p>My old blogs:</p>

<ul>
<li><a href="http://calculist.blogspot.com">http://calculist.blogspot.com</a></li>
<li><a href="http://blog.mozilla.com/dherman">http://blog.mozilla.com/dherman</a></li>
</ul>


<p>should stick around indefinitely as archives but they&#8217;ll be inactive from now on.</p>
]]></content>
  </entry>
  
</feed>
