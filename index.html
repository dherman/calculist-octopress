
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>The Little Calculist</title>
  <meta name="author" content="Dave Herman">

  
  <meta name="description" content="Here&#8217;s the deal: typed arrays are not fully portable. On most browsers, this code will print 1: 1
2
3
var a1 = new Uint32Array([1]);
var a2 = &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://calculist.org">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The Little Calculist" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-27510188-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The Little Calculist</a></h1>
  
    <h2>A little lambda goes a long way</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:calculist.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/about.html">About</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/24/the-little-endian-web/">The little-endian web?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-24T22:32:00-07:00" pubdate data-updated="true">Apr 24<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Here&#8217;s the deal: <a href="http://www.khronos.org/registry/typedarray/specs/latest/">typed arrays</a> are not fully portable. On most browsers, this code will print 1:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">([</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">a1</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>But the typed arrays spec doesn&#8217;t specify a byte order. So a browser on a big-endian system (say, a PowerPC console like Xbox or PS3) is allowed to print 0. In short: <strong>casting an <code>ArrayBuffer</code> to different types is unportable by default.</strong> It&#8217;s up to web developers to canonicalize bytes for different architectures.</p>

<p><img class="right" src="/images/nuxi.jpg"></p>

<p>Now, we could just require typed arrays to be little-endian, once and for all. After all, almost all platforms are little-endian these days. The few big-endian platforms could just automatically reorder bytes for all typed array accesses. But this would have to be made to work with WebGL, which works by sending application-generated buffers to the GPU. In order to make this work on a big-endian architecture, little-endian-encoded <code>ArrayBuffer</code> data would need to be translated when sending back and forth to the GPU. Technically, <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-March/035236.html">this might be possible</a>, but there&#8217;s really no evidence that it would have acceptable performance.</p>

<p>On the other hand, can we really trust that web applications will write portable code? Imagine a <a href="http://blog.faultylabs.com/files/md5.js">hashing algorithm</a> that builds an internal <code>ArrayBuffer</code> and casts it to different types. If the code isn&#8217;t written portably, it&#8217;ll break on a browser implementing big-endian typed arrays.</p>

<p>This leaves big-endian browsers with a <strong>nasty decision</strong>: try to emulate little-endian typed arrays to protect against unportable application logic, and suffer the complexity and performance costs of translating data back and forth to the GPU, or just hope that not too many web pages break. Or perhaps surface an annoying decision to users: do you want to run this application in fast mode or correct mode?</p>

<p>For now, we should let browser vendors on big-endian systems make that decision, and not force the decision through the spec. If they end up all choosing to emulate little-endian, I&#8217;ll be happy to codify that in the standards. As I understand it, <a href="http://www.floodgap.com/software/tenfourfox/">TenFourFox</a> can&#8217;t support WebGL, so there the best decision is probably to emulate little-endianness. On an Xbox, I would guess WebGL performance would be a higher priority than web sites using internal <code>ArrayBuffer</code>s. But I&#8217;m not sure. I&#8217;d say this is a decision for big-endian browsers to make, but <strong>I would greatly welcome their input</strong>.</p>

<p>In the meantime, we should do everything we can to make portability more attractive and convenient. For working with I/O, where you need explicit control over endianness, applications can use <a href="https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView">DataView</a>. For heterogeneous data, there&#8217;ll be ES6 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:binary_data">structs</a>. Finally, I&#8217;d like to add an option for <code>ArrayBuffer</code>s and typed arrays to be given an optional explicit endianness:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="s2">&quot;little&quot;</span><span class="p">);</span> <span class="c1">// a little-endian buffer</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</span><span class='line'><span class="nx">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// must be 1, regardless of system architecture</span>
</span></code></pre></td></tr></table></div></figure>


<p>With the endianness specified explicitly, you can still easily write portable logic even when casting&#8212;without having to canonicalize bytes yourself. <a href="https://github.com/kripken/emscripten">Emscripten</a> and <a href="http://www.mandreel.com/">Mandreel</a> could benefit from this increased portability, for example, and I think crypto algorithms would as well. I&#8217;ll propose this extension to Khronos and TC39, and discuss it with JavaScript engine implementors.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/04/17/homoiconicity-isnt-the-point/">Homoiconicity isn&#8217;t the point</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-04-17T07:51:00-07:00" pubdate data-updated="true">Apr 17<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I&#8217;ve never really understood what &#8220;homoiconic&#8221; is supposed to mean. People often say something like &#8220;the syntax uses one of the language&#8217;s basic data structures.&#8221; That&#8217;s a category error: syntax is not a data structure, it&#8217;s just a representation of data as text. Or you hear &#8220;<a href="http://smallcultfollowing.com/babysteps/blog/2012/04/15/syntax-matters-dot-dot-dot/">the syntax of the language is the same as the syntax of its data structures</a>.&#8221; But S-expressions don&#8217;t &#8220;belong&#8221; to Lisp; there&#8217;s no reason why Perl or Haskell or JavaScript couldn&#8217;t have S-expression libraries. And every parser generates a data structure, so if you have a <a href="http://docs.python.org/library/parser.html">Python parser in Python</a>, then is Python homoiconic? Is <a href="http://esprima.org/">JavaScript</a>?</p>

<p>Maybe there&#8217;s a more precise way to define homoiconicity, but frankly I think it misses the point. What makes Lisp&#8217;s syntax powerful is not the fact that it can be represented as a data structure, it&#8217;s that <strong>it&#8217;s possible to <em>read</em> it without <em>parsing</em></strong>.</p>

<p>Wait, what?</p>

<p>It&#8217;s hard to explain these concepts with traditional terminology, because the distinction between reading and parsing simply doesn&#8217;t exist for languages without macros.</p>

<h3>Parsing vs reading: the compiler&#8217;s view</h3>

<p>In almost every non-Lispy language ever, the front end of every interpreter and compiler looks pretty much the same:</p>

<p><img class="center" src="/images/parse-pipeline.png"></p>

<p>Take the text, run it through a parser, and you get out an AST. But that&#8217;s not how it works when you have macros. You simply can&#8217;t produce an AST without expanding macros first. So the front-end of a Lispy language usually looks more like:</p>

<p><img class="center" src="/images/macro-pipeline.png"></p>

<p>What&#8217;s this intermediate syntax tree? It&#8217;s an almost entirely superficial understanding of your program: it basically does paren-matching to create a tree representing the surface nesting structure of the text. This is nowhere near an AST, but it&#8217;s just enough for the macro expansion system to do its job.</p>

<h3>Parsing vs reading: the macro expander&#8217;s view</h3>

<p>If you see this statement in the middle of a JavaScript program:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="nx">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">print</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>you know for sure that it&#8217;s a <em>ForInStatement</em>, as defined by the spec (I&#8217;m using <code>let</code> because&#8230; ES6, that&#8217;s why). If you know the grammar of JavaScript, you know the entire structure of the statement. But in Scheme, we could implement <code>for</code> as a macro. When the macro expander encounters:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">key</span> <span class="nv">obj</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>it knows nothing about the contents of the expression. All it knows is the macro definition of <code>for</code>. But that&#8217;s all it needs to know! The expander just takes the two subtrees, <code>(key obj)</code> and <code>(print key)</code>, and passes them as arguments to the <code>for</code> macro.</p>

<h3>Parsing vs reading: the macro&#8217;s view</h3>

<p>Here&#8217;s a simple <code>for</code> macro, written in <a href="http://docs.racket-lang.org/guide/pattern-macros.html#%28part._define-syntax-rule%29">Racket</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">define-syntax-rule</span> <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">e1</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="nv">e2</span><span class="p">)</span> <span class="nv">e1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This macro works by <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>: it expects two sub-trees, the first of which can itself be broken down into two identifier nodes <code>x</code> and <code>e1</code>, and it expands into the <code>for-each</code> expression. So when the expander calls the macro with the above example, the result of expansion is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">for-each </span><span class="p">(</span><span class="err">λ</span> <span class="p">(</span><span class="nf">key</span><span class="p">)</span> <span class="p">(</span><span class="nf">print</span> <span class="nv">key</span><span class="p">))</span> <span class="nv">obj</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The power of the parenthesis</h3>

<p>If you&#8217;ve ever wondered why Lisp weirdos are so inexplicably attached to their parentheses, this is what it&#8217;s all about. Parentheses make it unambiguous for the expander to understand what the arguments to a macro are, because <strong>it&#8217;s always clear where the arguments begin and end</strong>. It knows this without needing to understand anything about what the macro definition is going to do. Imagine trying to define a macro expander for a language with syntax like JavaScript&#8217;s. What should the expander do when it sees:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">quux</span> <span class="p">(</span><span class="nx">mumble</span><span class="p">,</span> <span class="nx">flarg</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="nx">grunch</span> <span class="o">/</span><span class="nx">wibble</span><span class="o">/</span><span class="nx">i</span>
</span></code></pre></td></tr></table></div></figure>


<p>How many arguments does <code>quux</code> take? Is the curly-braced argument a block statement or an object literal? Is the thing at the end an arithmetic expression or a regular expression literal? These are all questions that can&#8217;t be answered in JavaScript without knowing your parsing context&#8212;and macros obscure the parsing context.</p>

<p>None of this is to say that it&#8217;s <em>impossible</em> to design a macro system for languages with non-Lispy syntax. My point is just that the power of Lisp&#8217;s (Scheme&#8217;s, Racket&#8217;s, Clojure&#8217;s, &#8230;) macros comes not from being somehow tied to a central data structure of the language, but rather to the expander&#8217;s ability to break up a macro call into its separate arguments and then let the macro do all the work of parsing those arguments. In other words, <strong>homoiconicity isn&#8217;t the point, <code>read</code> is</strong>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/29/synchronous-module-loading-in-es6/">Synchronous module loading in ES6</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-29T07:41:00-07:00" pubdate data-updated="true">Mar 29<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>One of the great features of ES6 modules is the direct style module loading syntax:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">map</span> <span class="nx">from</span> <span class="s2">&quot;underscore.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>This makes it as frictionless as possible to grow or refactor your code into multiple modules, and to pull third-party modules into an existing codebase. It also makes a common module format that can be shared between the browser and JS servers like Node.</p>

<p>But this direct style requires loading its dependencies before it can execute. That is, it&#8217;s a synchronous module load. Put in the context of a <code>script</code> tag, this would make it all too easy to block page rendering on I/O:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><img class="right" src="/images/boromir-sync.jpg"> Throwing this syntax into the browser like this would be an <a href="https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Synchronous_and_asynchronous_requests">invitation to jank</a>. Thanks to insight from <a href="http://blogs.msdn.com/b/lukeh">Luke Hoban</a>, I think we have the right approach to this for ES6, which is in fact similar to our approach to avoiding turning <code>eval</code> into a synchronous I/O operation.</p>

<p>In previous versions of ECMAScript, there&#8217;s only one syntactic category of program that you can evaluate, called <code>Program</code> in the grammar. In ES6, we&#8217;ll define a restricted version of the syntax to be used in synchronous settings, which makes it illegal to do synchronous loads. Within a blocking script, the only access to modules is via the dynamic loading API:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="nx">System</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;jquery.js&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This eliminates the footgun, and all of your modules can themselves use the synchronous loading syntax. For example, if <code>jquery.js</code> wants to use a module&#8212;say, a data structure library&#8212;it can go ahead and load it synchronously:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// jquery.js</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">Stack</span> <span class="nx">from</span> <span class="s2">&quot;utils.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>But still, this restriction on the top-level loses the convenience of directly importing modules from scripts. Thing is, in an asynchronous context, there&#8217;s nothing wrong with doing a synchronous load. So just like the asynchronously loaded <code>jquery.js</code> can use the synchronous syntax, we can also allow it in a <code>defer</code> or <code>async</code> script:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script </span><span class="na">async</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows the full flexibility and expressiveness of ES6 embedded in HTML, without any hazard of blocking page rendering for I/O.</p>

<p>The <code>eval</code> function for ES6 will work the same way, disallowing synchronous loading syntax in the grammar it recognizes, to prevent turning it into a synchronous API. We&#8217;ll also add an asynchronous version of <code>eval</code> that, like <code>script async</code>, recognizes the full grammar.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/01/10/two-years-at-moco/">Two years at MoCo</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-10T08:13:00-08:00" pubdate data-updated="true">Jan 10<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>If I remember right, today is my two year anniversary working full time at Mozilla. And it works out to about six years of working with Mozilla and <a href="http://www.ecma-international.org/memento/TC39.htm">TC39</a>. I could stop and get sentimental, but <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals">there&#8217;s work to do</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">Why coroutines won&#8217;t work on the web</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-14T10:30:00-08:00" pubdate data-updated="true">Dec 14<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="right" src="/images/yunocoros.jpg"> The topic of coroutines (or
fibers, or continuations) for JavaScript comes up from time to time,
so I figured I&#8217;d write down my thoughts on the matter. I admit to
having a soft spot for crazy control-flow features like continuations,
but they&#8217;re unlikely ever to make it into ECMAScript. With good
reason.</p>

<p>The big justification for coroutines in JavaScript is non-blocking
I/O. As we all know, asynchronous I/O leads to callback API&#8217;s, which
lead to nested lambdas, which lead to&#8230; the pyramid of doom:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">range</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;preheat&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">pot</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;boil&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">rice</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;cooked&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">dinner</span><span class="p">.</span><span class="nx">serve</span><span class="p">(</span><span class="nx">rice</span><span class="p">);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/05/obligatory-fawning-over-octopress/">Obligatory fawning over Octopress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-05T21:14:00-08:00" pubdate data-updated="true">Dec 5<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I&#8217;m joining the throngs of programmer-bloggers using <a href="http://octopress.org">Octopress</a> for my new blog.
There&#8217;s so much to commend about it, but it really comes down to one thing:</p>

<p><em>Programmers should be able to write their blogs in text editors.</em></p>

<p>Also, from now on, everything I ever do in my life should be in GitHub.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/05/hello/">Hello, world</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-05T16:00:00-08:00" pubdate data-updated="true">Dec 5<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is my blog&#8217;s new home.</p>

<p>My old blogs:</p>

<ul>
<li><a href="http://calculist.blogspot.com">http://calculist.blogspot.com</a></li>
<li><a href="http://blog.mozilla.com/dherman">http://blog.mozilla.com/dherman</a></li>
</ul>


<p>should stick around indefinitely as archives but they&#8217;ll be inactive from now on.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/04/24/the-little-endian-web/">The little-endian web?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/04/17/homoiconicity-isnt-the-point/">Homoiconicity isn&#8217;t the point</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/03/29/synchronous-module-loading-in-es6/">Synchronous module loading in ES6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/10/two-years-at-moco/">Two years at MoCo</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">Why coroutines won&#8217;t work on the web</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("littlecalculist", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/littlecalculist" class="twitter-follow-button" data-width="208px" data-show-count="false">Follow @littlecalculist</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Dave Herman -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'littlecalculist';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
