<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: modules | The Little Calculist]]></title>
  <link href="http://calculist.org/blog/categories/modules/atom.xml" rel="self"/>
  <link href="http://calculist.org/"/>
  <updated>2012-07-16T16:26:04-07:00</updated>
  <id>http://calculist.org/</id>
  <author>
    <name><![CDATA[Dave Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Static module resolution]]></title>
    <link href="http://calculist.org/blog/2012/06/29/static-module-resolution/"/>
    <updated>2012-06-29T13:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/06/29/static-module-resolution</id>
    <content type="html"><![CDATA[<p>I haven't spoken enough about the rationale for declarative, static module resolution in <a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">ES6 modules</a>. Since multiple module systems exist in pure JS, the concept of modules that involve new syntax is coming across as foreign to people. I'd like to explain the motivation.</p>

<p>First, a quick explanation of what this is about. In a pure-JS system like CommonJS, modules are just objects, and whatever definitions they export can be imported by a client with object property lookup:
<code>javascript
var { stat, exists, readFile } = require('fs');
</code>
By contrast, in the ES6 module system, modules are not objects, they're declarative collections of code. Importing definitions from a module is also declarative:
<code>javascript
import { stat, exists, readFile } from 'fs';
</code>
This import is resolved at compile time---that is, before the script starts executing. All the imports and exports of the declarative module dependency graph are resolved before execution. (There's also an asynchronous dynamic loading API; it's of course important to be able to defer module loading to runtime. But this post is about the resolution of a declarative module dependency graph.)</p>

<h2>On the origin of specs</h2>

<p><img class="right" src="/images/evolution.jpg"></p>

<p>Node leaders are arguing that we should take more incremental, evolutionary steps, that we should hew more closely to the module systems that exist today. I have a lot of sympathy for the "pave the cowpaths" philosophy, and I often argue for it. But the module systems people have built for JavaScript to date did not have the option of modifying the language. We have an opportunity to move JS in directions where a purely dynamic system could never go.</p>

<p>What are some of those directions?</p>

<h2>Fast lookup</h2>

<p>Static imports (whether via <code>import</code> or references like <code>m.foo</code>) can always be compiled like variable references. In a dynamic module system, an explicit dereference like <code>m.foo</code> will be an object reference, which will generally require <a href="http://blog.cdleary.com/2010/09/picing-on-javascript-for-fun-and-profit/">PIC guards</a>. If you copy them into locals, they'll be more optimizable in some cases, but with static modules you always predictably get early binding. Keeping module references as cheap as variable references makes modular programs faster and avoids imposing a tax on modular code.</p>

<h2>Early variable checking</h2>

<p>Having variable references, including imports and exports, checked before a script starts running is, in my experience, very useful for making sure the basic top-level structure of a program is sane. JavaScript is almost statically scoped, and this is our one and only chance to get there. James Burke dismisses this as a kind of <a href="http://tagneto.blogspot.ca/2012/06/es-modules-suggestions-for-improvement.html">shallow type checking</a>, which he claims is not enough to be useful. My experience in other languages says otherwise â€” it is super useful! Variable checking is a nice sweet spot where you can still write expressive dynamic programs, but catch really basic and common errors. As Anton Kovalyov points out, unbound variable reporting is a <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-June/023777.html">popular feature in JSHint</a>, and it's so much nicer not to have to run a separate linter to catch these bugs.</p>

<h2>Cyclic dependencies</h2>

<p>Allowing cyclic dependencies between modules is really important. Mutual recursion is a fact of programming. It occurs sometimes without you even noticing it. If you try splitting up your program into modules and the system breaks because it can't handle cycles, the easiest workaround is just to keep everything together in one big module. Module systems should not prevent programmers from splitting up their program however they see fit. They should not provide disincentives from writing modular programs.</p>

<p>This isn't impossible with dynamic systems, but it tends to be something I see treated as an afterthought by alternative proposals. It's something we've thought very carefully about for ES6. Also, declarative modules allow you to pre-initialize more of the module structure before executing any code, so that you can give better errors if someone refers to a not-yet-assigned export. For example, a <code>let</code> binding throws if you refer to it before it's been assigned, and you get a clear error message. This is much easier to diagnose than referring to a property of a dynamic module object that just isn't even there yet, getting <code>undefined</code>, and having to trace the eventual error back to the source.</p>

<h2>Future-compatibility for macros</h2>

<p>One of the things I would love to see in JavaScript's future is the ability for programmers to come up with their own custom syntax extensions without having to wait for TC39 to add it. Today, people invent new syntax by writing their own compilers. But this is extremely hard to do, and you can't use different syntax features from different compilers in a single source file.</p>

<p>With macros, you might implement, say, a new <code>cond</code> syntax that makes a nicer alternative to chaining <code>? :</code> conditionals, and share that via a library:
```javascript
import cond from 'cond.js';
...
var type = cond {</p>

<pre><code>case (x === null): "null",
case Array.isArray(x): "array",
case (typeof x === "object"): "object",
default: typeof x
</code></pre>

<p>};
<code>
The `cond` macro would preprocess this into a chain of conditionals before the program runs. Preprocessing doesn't work with purely dynamic modules:
</code>javascript
var cond = require('cond.js');
...
// impossible to preprocess because we haven't evaluated the require!
var type = cond { /<em> etc </em>/ };
```</p>

<h2>Future-compatibility for types</h2>

<p>I joined TC39 in the ill-fated ES4 days, when the committee was working on an optional type system for JS. It was built on sketchy foundations and ultimately fell apart. One of the things that was really lacking was a module system where you could draw a boundary around a section of code and say "this part needs to be type-checked." Otherwise you never knew if more code was going to be appended later.</p>

<p>Why types? Here's one reason: JS is fast and getting faster, but it only gets <a href="http://blog.mrale.ph/post/12396216081/the-trap-of-the-performance-sweet-spot">harder to predict performance</a>. With experiments like <a href="http://lljs.org">LLJS</a>, my group at Mozilla is playing with dialects of JS that use types to pre-compile offline and generate some pretty funky JS code optimized for current JIT's. But if you could just directly write your high-performance kernels in a typed dialect of JS, modern compilers could go to town with it.</p>

<p>With declarative resolution, you can import and export typed definitions and they can all be checked at compile-time. Dynamic imports can't be statically checked.</p>

<h2>Inter-language modularity</h2>

<p>Some people may not care about or want features like macros or types. But JavaScript has to serve many different programmers who come with many different development practices and needs. And one of the ways it can do so is by allowing people to use their own languages that compile to JavaScript. So even if macros or types aren't in the future of the ECMAScript standard, it'd be pretty great if you could use statically typed or macro-enabled dialects of JS offline that compile to browser-compatible JS. People are already doing this kind of thing today with the <a href="https://developers.google.com/closure/compiler/">Closure compiler</a>'s type checking, or the <a href="http://roy.brianmckenna.org/">Roy</a> language, or <a href="https://github.com/clojure/clojurescript">ClojureScript</a>. A static module system is more universally and straightforwardly compatible with a wider range of languages.</p>

<h2>Costs and benefits</h2>

<p>The above are some of the benefits that I see to declarative module resolution. Isaac Schlueter says the <code>import</code> syntax <a href="http://blog.izs.me/post/25906678790/on-es-6-modules">adds nothing</a>. That's unfair and wrong. It's there for a purpose. I don't believe that a declarative import syntax is a high cost for the benefit both to ES6 and to potential future editions.</p>

<h2>PS: What's all this about Python?</h2>

<p>One last thing: people keep claiming that the ES6 module system came from Python. I don't even have very much experience with Python. And Python's modules are more mutable and their scope is more dynamic. Personally, I've drawn inspiration from <a href="http://racket-lang.org">Racket</a>, which has gotten lots of mileage out of its <a href="http://docs.racket-lang.org/guide/Module_Syntax.html">declarative module system</a>. They've leveraged static modules to build a macro system, early variable checking, optimized references, dynamic contracts with module-based blame reporting, multi-language interoperability, and a statically typed dialect.</p>

<p>I'm not interested in making JavaScript into some other language. But you can learn a lot from studying precedent in other languages. I've seen firsthand the benefits you can get from a declarative module system in a dynamic language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synchronous module loading in ES6]]></title>
    <link href="http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/"/>
    <updated>2012-03-29T07:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6</id>
    <content type="html"><![CDATA[<p>One of the great features of ES6 modules is the direct style module loading syntax:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">map</span> <span class="nx">from</span> <span class="s2">&quot;underscore.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This makes it as frictionless as possible to grow or refactor your code into multiple modules, and to pull third-party modules into an existing codebase. It also makes a common module format that can be shared between the browser and JS servers like Node.</p>

<p>But this direct style requires loading its dependencies before it can execute. That is, it's a synchronous module load. Put in the context of a <code>script</code> tag, this would make it all too easy to block page rendering on I/O:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><img class="right" src="/images/boromir-sync.jpg"> Throwing this syntax into the browser like this would be an <a href="https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Synchronous_and_asynchronous_requests">invitation to jank</a>. Thanks to insight from <a href="http://blogs.msdn.com/b/lukeh">Luke Hoban</a>, I think we have the right approach to this for ES6, which is in fact similar to our approach to avoiding turning <code>eval</code> into a synchronous I/O operation.</p>

<p>In previous versions of ECMAScript, there's only one syntactic category of program that you can evaluate, called <code>Program</code> in the grammar. In ES6, we'll define a restricted version of the syntax to be used in synchronous settings, which makes it illegal to do synchronous loads. Within a blocking script, the only access to modules is via the dynamic loading API:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="nx">System</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;jquery.js&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This eliminates the footgun, and all of your modules can themselves use the synchronous loading syntax. For example, if <code>jquery.js</code> wants to use a module---say, a data structure library---it can go ahead and load it synchronously:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// jquery.js</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">Stack</span> <span class="nx">from</span> <span class="s2">&quot;utils.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>But still, this restriction on the top-level loses the convenience of directly importing modules from scripts. Thing is, in an asynchronous context, there's nothing wrong with doing a synchronous load. So just like the asynchronously loaded <code>jquery.js</code> can use the synchronous syntax, we can also allow it in a <code>defer</code> or <code>async</code> script:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">async</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This allows the full flexibility and expressiveness of ES6 embedded in HTML, without any hazard of blocking page rendering for I/O.</p>

<p>The <code>eval</code> function for ES6 will work the same way, disallowing synchronous loading syntax in the grammar it recognizes, to prevent turning it into a synchronous API. We'll also add an asynchronous version of <code>eval</code> that, like <code>script async</code>, recognizes the full grammar.</p>
]]></content>
  </entry>
  
</feed>
