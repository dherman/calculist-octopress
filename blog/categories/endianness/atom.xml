<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: endianness | The Little Calculist]]></title>
  <link href="http://calculist.org/blog/categories/endianness/atom.xml" rel="self"/>
  <link href="http://calculist.org/"/>
  <updated>2012-07-16T16:26:04-07:00</updated>
  <id>http://calculist.org/</id>
  <author>
    <name><![CDATA[Dave Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The little-endian web!]]></title>
    <link href="http://calculist.org/blog/2012/04/25/the-little-endian-web/"/>
    <updated>2012-04-25T12:29:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/25/the-little-endian-web</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/The_Gates_of_Hell"><img class="right" src="/images/gates-of-hell.jpg"></a></p>

<blockquote><p><a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">This</a> feels a little bit like the web platform having opened a door to hell and Zombies running out of it. I wonder if we can ever close it again.
-- <a href="https://plus.google.com/u/1/116910304844117268718/posts/9fdegEJkAtt">Malte Ubl</a></p></blockquote>

<p>Let's see if we can. I've had a bunch of productive conversations since my <a href="http://calculist.org/blog/2012/04/24/the-little-endian-web/">post</a> the other day.</p>

<p>I talked about how specifying little-endian would force big-endian browser vendors to choose one implementation strategy---emulate little-endian by byte-swapping and try to optimize as best they can---and concluded that it was better to let them decide for themselves and see how the market shakes out before specifying. But that doesn't take into account the cost to web developers, which should always be the first priority (mea culpa).</p>

<p>Leaving it unspecified or forcing developers to opt in to a specified endianness taxes developers: it leaves them open to the possibility of their sites breaking on systems they likely can't even test on, or forces them to make sure they pass the argument (in which case, they'd always be one forgotten argument away from possible bustage on some platform they can't test on).</p>

<p>Imagine that instead of defaulting to unspecified behavior, we defaulted to little-endian---which is the de facto semantics of the web today---but apps could opt in to big-endian with an optional argument. Then a carefully-written app could use this (in combination with, say, a <code>navigator.endianness</code> feature test API) to decide which byte order would give them better performance. On little-endian systems, they'd use little-endian, on big-endian systems, they'd use big-endian. Less carefully-written apps that just went with the default might get some performance degradation in big-endian platforms, but we don't actually know how bad it would be. But crucially, <strong>there would be no way to accidentally break your app's behavior</strong>.</p>

<p>But let me take it one step further. I don't even think we know that that additional option will be needed. For now, we don't even know of any big-endian user agents that are implementing WebGL, nor do we know if byte-swapping will be prohibitively expensive. Until then, I say any additional API surface area is premature optimization. <a href="http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it">YAGNI</a>.</p>

<p>In summary: let's prioritize web developers over hypothetical performance issues on hypothetical browsers. <strong>Typed arrays should be standardized as little-endian</strong>---full stop.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The little-endian web?]]></title>
    <link href="http://calculist.org/blog/2012/04/24/the-little-endian-web/"/>
    <updated>2012-04-24T22:32:00-07:00</updated>
    <id>http://calculist.org/blog/2012/04/24/the-little-endian-web</id>
    <content type="html"><![CDATA[<p>Here's the deal: <a href="http://www.khronos.org/registry/typedarray/specs/latest/">typed arrays</a> are not fully portable. On most browsers, this code will print 1:</p>

<p><code>javascript
var a1 = new Uint32Array([1]);
var a2 = new Uint8Array(a1.buffer);
console.log(a2[0])
</code></p>

<p>But the typed arrays spec doesn't specify a byte order. So a browser on a big-endian system (say, a PowerPC console like Xbox or PS3) is allowed to print 0. In short: <strong>casting an <code>ArrayBuffer</code> to different types is unportable by default.</strong> It's up to web developers to canonicalize bytes for different architectures.</p>

<p><img class="right" src="/images/nuxi.jpg"></p>

<p>Now, we could just require typed arrays to be little-endian, once and for all. After all, almost all platforms are little-endian these days. The few big-endian platforms could just automatically reorder bytes for all typed array accesses. But this would have to be made to work with WebGL, which works by sending application-generated buffers to the GPU. In order to make this work on a big-endian architecture, little-endian-encoded <code>ArrayBuffer</code> data would need to be translated when sending back and forth to the GPU. Technically, <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-March/035236.html">this might be possible</a>, but there's really no evidence that it would have acceptable performance.</p>

<p>On the other hand, can we really trust that web applications will write portable code? Imagine a <a href="http://blog.faultylabs.com/files/md5.js">hashing algorithm</a> that builds an internal <code>ArrayBuffer</code> and casts it to different types. If the code isn't written portably, it'll break on a browser implementing big-endian typed arrays.</p>

<p>This leaves big-endian browsers with a <strong>nasty decision</strong>: try to emulate little-endian typed arrays to protect against unportable application logic, and suffer the complexity and performance costs of translating data back and forth to the GPU, or just hope that not too many web pages break. Or perhaps surface an annoying decision to users: do you want to run this application in fast mode or correct mode?</p>

<p>For now, we should let browser vendors on big-endian systems make that decision, and not force the decision through the spec. If they end up all choosing to emulate little-endian, I'll be happy to codify that in the standards. As I understand it, <a href="http://www.floodgap.com/software/tenfourfox/">TenFourFox</a> can't support WebGL, so there the best decision is probably to emulate little-endianness. On an Xbox, I would guess WebGL performance would be a higher priority than web sites using internal <code>ArrayBuffer</code>s. But I'm not sure. I'd say this is a decision for big-endian browsers to make, but <strong>I would greatly welcome their input</strong>.</p>

<p>In the meantime, we should do everything we can to make portability more attractive and convenient. For working with I/O, where you need explicit control over endianness, applications can use <a href="https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView">DataView</a>. For heterogeneous data, there'll be ES6 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:binary_data">structs</a>. Finally, I'd like to add an option for <code>ArrayBuffer</code>s and typed arrays to be given an optional explicit endianness:</p>

<p><code>javascript
var buffer = new ArrayBuffer(1024, "little"); // a little-endian buffer
var a1 = new Uint32Array(buffer);
a1[0] = 1;
var a2 = new Uint8Array(buffer);
a2[0]; // must be 1, regardless of system architecture
</code></p>

<p>With the endianness specified explicitly, you can still easily write portable logic even when casting---without having to canonicalize bytes yourself. <a href="https://github.com/kripken/emscripten">Emscripten</a> and <a href="http://www.mandreel.com/">Mandreel</a> could benefit from this increased portability, for example, and I think crypto algorithms would as well. I'll propose this extension to Khronos and TC39, and discuss it with JavaScript engine implementors.</p>
]]></content>
  </entry>
  
</feed>
