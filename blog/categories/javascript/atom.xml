<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | The Little Calculist]]></title>
  <link href="http://calculist.org/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://calculist.org/"/>
  <updated>2012-07-16T16:26:04-07:00</updated>
  <id>http://calculist.org/</id>
  <author>
    <name><![CDATA[Dave Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript's two array types]]></title>
    <link href="http://calculist.org/blog/2012/07/16/javascripts-two-array-types/"/>
    <updated>2012-07-16T15:06:00-07:00</updated>
    <id>http://calculist.org/blog/2012/07/16/javascripts-two-array-types</id>
    <content type="html"><![CDATA[<p>Imagine a <code>BitSet</code> constructor with an overloaded API for setting bits:</p>

<p>```javascript
var bits = new BitSet();</p>

<p>bits.set(4);
bits.set([1, 4, 8, 17]);
```</p>

<p>The interface for <code>BitSet.prototype.set</code> is:</p>

<p><code>
// set :: (number | [number]) -&gt; undefined
</code></p>

<p>Now imagine a <code>StringSet</code> constructor with an overloaded API for adding strings:</p>

<p>```javascript
var set = new StringSet();</p>

<p>set.add('foo');
set.add(['foo', 'bar', 'baz']);
set.add({ foo: true, bar: true, baz: true });
```</p>

<p>The interface for <code>StringSet.prototype.add</code> is something like:</p>

<p><code>
// add :: (string | [string] | object) -&gt; undefined
</code></p>

<p>These both look pretty similar, but there's a critical difference. Think about how you might implement <code>BitSet.prototype.set</code>:</p>

<p>```javascript
BitSet.prototype.set = function set(x) {</p>

<pre><code>// number case
if (typeof x === 'number') {
    this._add1(x);
    return;
}
// array case
for (var i = 0, n = x.length; i &lt; n; i++) {
    this._add1(x[i]);
}
</code></pre>

<p>};
```</p>

<p>Now think about how you might implement <code>StringSet.prototype.add</code>:</p>

<p>```javascript
StringSet.prototype.add = function add(x) {</p>

<pre><code>// string case
if (typeof x === 'string') {
    this._add1(x);
    return;
}
// array case
if (/* hmmmm... */) {
    for (var i = 0, n = x.length; i &lt; n; i++) {
        this._add1(x[i]);
    }
    return;
}
// object case
for (var key in x) {
    if ({}.hasOwnProperty.call(x, key)) {
        this._add1(key);
    }
}
</code></pre>

<p>};
```</p>

<p>What's the difference? <code>BitSet.prototype.set</code> doesn't have to test whether its argument is an array. It'll work for any object that acts like an array (i.e., has indexed properties and a numeric <code>length</code> property). It'll even accept values like an <code>arguments</code> object, a <code>NodeList</code>, some custom object you create that acts like an array, or even a primitive string.</p>

<p>But <code>StringSet.prototype.add</code> actually needs a test to see if <code>x</code> is an array. How do you distinguish between arrays and objects when JavaScript arrays <em>are</em> objects?</p>

<p>One answer you'll sometimes see is what I call "duck testing": use some sort of heuristic that <em>probably</em> indicates the client intended the argument to be an array:</p>

<p>```javascript
if (typeof x.length === 'number') {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>Beware the word "probably" in programming! Duck testing is a horribly medieval form of computer science:</p>

<iframe width="640" height="390" src="http://www.youtube.com/embed/zrzMhU_4m-g" frameborder="0" allowfullscreen></iframe>


<p>For example, what happens when a user happens to pass in a dictionary object with the string <code>'length'</code>?</p>

<p><code>javascript
symbolTable.add({ a: 1, i: 1, length: 1 });
</code></p>

<p>The user clearly intended this to be the dictionary case, but the duck test saw a numeric <code>'length'</code> property and gleefully proclaimed "it's an array!"</p>

<p>This comes down to the difference between <em>nominal</em> and <em>structural</em> types.</p>

<p>A <strong>nominal type</strong> is a type that has a unique identity or "brand." It carries a tag with it that can be atomically tested to distinguish it from other types.</p>

<p>A <strong>structural type</strong>, also known as a duck type, is a kind of interface: it's just a contract that mandates certain behaviors, but doesn't say anything about what specific implementation is used to provide that behavior. The reason people have such a hard time figuring out how to test for structural types is that they are designed specifically <em>not to be testable</em>!</p>

<p>There are a few common scenarios in dynamically typed languages where you need to do dynamic type testing, such as error checking, debugging, and inrospection. But the most common case is when implementing overloaded API's like the <code>set</code> and <code>add</code> methods above.</p>

<p>The <code>BitSet.prototype.set</code> method treats arrays as a structural type: they can be any kind of value whatsoever as long as they have indexed properties with corresponding <code>length</code>. But <code>StringSet.prototype.add</code> overloads array and object types, so it has to check for "arrayness." And you can't reliably check for structural types.</p>

<p>It's specifically when you <strong>overload arrays and objects</strong> that you need a predictable nominal type test. One answer would be to punt and change the API so the client has to explicitly tag the variants:</p>

<p><code>javascript
set.add({ key: 'foo' });
set.add({ array: ['foo', 'bar', 'baz'] });
set.add({ dict: { foo: true, bar: true, baz: true } });
</code></p>

<p>This overloads three different objects types that can be distinguished by their relevant property names. Or you could get rid of overloading altogether:</p>

<p><code>javascript
set.add('foo');
set.addArray(['foo', 'bar', 'baz']);
set.addDict({ foo: true, bar: true, baz: true });
</code></p>

<p>But these API's are heavier and clunkier. Rather than rigidly avoiding overloading arrays and objects, the lighter-weight approach is to use JavaScript's latent notion of a "true" array: an object whose <a href="http://es5.github.com/#x8.6.2">[[Class]] internal property</a> is <code>"Array"</code>. That internal property serves as the brand for a built-in nominal type of JavaScript. And it's a pretty good candidate for a universally available nominal type: clients get the concise array literal syntax, and the ES5 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray</a> function (which can be <a href="http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/">shimmed pretty reliably</a> in older JavaScript engines) provides the exact test needed to implement the API.</p>

<p>But this test is very different from the structural type accepted by <code>BitSet.prototype.set</code>. For example, you can't pass an <code>arguments</code> object to <code>StringSet.prototype.add</code>:</p>

<p>```javascript
MyClass.prototype.update = function update() {</p>

<pre><code>this.wibbles.add(arguments);
</code></pre>

<p>};
```</p>

<p>This code clearly means to pass <code>arguments</code> as an array, but it'll get interpreted as a dictionary. Similarly, you can't pass a <code>NodeList</code>, or a primitive string, or any other JavaScript value that acts array-like.</p>

<p>In other words, <strong>JavaScript has <em>two</em> latent concepts of array types</strong>. Library writers should clearly document when their API's accept any <em>array-like</em> value (i.e., the structural type) and when they require a true array (i.e., the nominal type). That way clients know whether they need to convert array-like values to true arrays before passing them in.</p>

<p>As a final note, ES6's <a href="http://wiki.ecmascript.org/doku.php?id=strawman:array_extras">Array.from</a> API will do that exact conversion. This would make it very convenient, for example, for the <code>update</code> method above to be fixed:</p>

<p>```javascript
MyClass.prototype.update = function update() {</p>

<pre><code>this.wibbles.add(Array.from(arguments));
</code></pre>

<p>};
```</p>

<p><em>Thanks to Rick Waldron for helping me come to this understanding during an awesome IRC conversation this morning.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tweaking the JavaScript AST API]]></title>
    <link href="http://calculist.org/blog/2012/07/03/tweaking-the-javascript-ast-api/"/>
    <updated>2012-07-03T11:53:00-07:00</updated>
    <id>http://calculist.org/blog/2012/07/03/tweaking-the-javascript-ast-api</id>
    <content type="html"><![CDATA[<p>A couple years ago I created a <a href="https://developer.mozilla.org/en/SpiderMonkey/Parser_API">JavaScript parser API</a> and implemented SpiderMonkey's <a href="https://developer.mozilla.org/en/SpiderMonkey/Parser_API#Reflect.parse%28src.5B.2C_options.5D%29">Reflect.parse</a> library. Since then, there have been a couple of pure JavaScript implementations of the API, including Zach Carter's <a href="https://github.com/zaach/reflect.js">reflect.js</a> and Ariya Hidayat's <a href="http://esprima.org">Esprima</a> parser.</p>

<p>Over time, I've gotten a bunch of good critiques about the API from people. I probably don't want to make any huge changes, but there are a couple of small changes that would be nice:</p>

<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=770567">Bug 770567</a> - rename <code>callee</code> to <code>constructor</code> to match the documentation</li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=742612">Bug 742612</a> - separate guarded/unguarded catch clauses</li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678">Bug 745678</a> - range-based location info</li>
</ul>


<p>Ariya is graciously willing to change Esprima to keep in sync with SpiderMonkey. But some of these would affect existing clients of either library. I wanted to post this publicly to ask if there's anyone who would be opposed to us making the change. Ariya and I would make sure to be very clear about when we're making the change, and we'd try to batch the changes so that people don't have to keep repeatedly updating their code.</p>

<p>Feel free to leave a comment if you are using Esprima or <code>Reflect.parse</code> and have thoughts about this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synchronous module loading in ES6]]></title>
    <link href="http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/"/>
    <updated>2012-03-29T07:41:00-07:00</updated>
    <id>http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6</id>
    <content type="html"><![CDATA[<p>One of the great features of ES6 modules is the direct style module loading syntax:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kr">import</span> <span class="nx">map</span> <span class="nx">from</span> <span class="s2">&quot;underscore.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This makes it as frictionless as possible to grow or refactor your code into multiple modules, and to pull third-party modules into an existing codebase. It also makes a common module format that can be shared between the browser and JS servers like Node.</p>

<p>But this direct style requires loading its dependencies before it can execute. That is, it's a synchronous module load. Put in the context of a <code>script</code> tag, this would make it all too easy to block page rendering on I/O:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><img class="right" src="/images/boromir-sync.jpg"> Throwing this syntax into the browser like this would be an <a href="https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Synchronous_and_asynchronous_requests">invitation to jank</a>. Thanks to insight from <a href="http://blogs.msdn.com/b/lukeh">Luke Hoban</a>, I think we have the right approach to this for ES6, which is in fact similar to our approach to avoiding turning <code>eval</code> into a synchronous I/O operation.</p>

<p>In previous versions of ECMAScript, there's only one syntactic category of program that you can evaluate, called <code>Program</code> in the grammar. In ES6, we'll define a restricted version of the syntax to be used in synchronous settings, which makes it illegal to do synchronous loads. Within a blocking script, the only access to modules is via the dynamic loading API:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="nx">System</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="s2">&quot;jquery.js&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This eliminates the footgun, and all of your modules can themselves use the synchronous loading syntax. For example, if <code>jquery.js</code> wants to use a module---say, a data structure library---it can go ahead and load it synchronously:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// jquery.js</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">Stack</span> <span class="nx">from</span> <span class="s2">&quot;utils.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>But still, this restriction on the top-level loses the convenience of directly importing modules from scripts. Thing is, in an asynchronous context, there's nothing wrong with doing a synchronous load. So just like the asynchronously loaded <code>jquery.js</code> can use the synchronous syntax, we can also allow it in a <code>defer</code> or <code>async</code> script:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">async</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s2">&quot;jquery.js&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;myelement&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">({</span> <span class="s1">&#39;background-color&#39;</span><span class="o">:</span> <span class="s1">&#39;yellow&#39;</span> <span class="p">})</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This allows the full flexibility and expressiveness of ES6 embedded in HTML, without any hazard of blocking page rendering for I/O.</p>

<p>The <code>eval</code> function for ES6 will work the same way, disallowing synchronous loading syntax in the grammar it recognizes, to prevent turning it into a synchronous API. We'll also add an asynchronous version of <code>eval</code> that, like <code>script async</code>, recognizes the full grammar.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why coroutines won't work on the web]]></title>
    <link href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/"/>
    <updated>2011-12-14T10:30:00-08:00</updated>
    <id>http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/yunocoros.jpg"> The topic of coroutines (or
fibers, or continuations) for JavaScript comes up from time to time,
so I figured I'd write down my thoughts on the matter. I admit to
having a soft spot for crazy control-flow features like continuations,
but they're unlikely ever to make it into ECMAScript. With good
reason.</p>

<p>The big justification for coroutines in JavaScript is non-blocking
I/O. As we all know, asynchronous I/O leads to callback API's, which
lead to nested lambdas, which lead to... the pyramid of doom:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">range</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;preheat&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">pot</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;boil&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">rice</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;cooked&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">dinner</span><span class="p">.</span><span class="nx">serve</span><span class="p">(</span><span class="nx">rice</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!--more-->


<p>Whereas, if you look at the README for
<a href="https://github.com/laverdet/node-fibers">node-fibers</a>, you'll see
this pleasant-looking example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok...&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>That looks pretty sweet. It's a synchronous version of <code>setTimeout</code>
that doesn't block the main thread. This seems like a nice combination
of the sequential style of synchronous code but with the
responsiveness of non-blocking I/O. Why wouldn't we want something
like this in ECMAScript?</p>

<h2>Coroutines are almost as pre-emptive as threads</h2>

<p>Part of the beauty of JavaScript's event loop is that there's a very
clear synchronization point for reaching a stable state in your
programs: the end of the current turn. You can go ahead and leave
things in a funky intermediate state for as long as you like, and as
long as you stitch everything back up in time for the next spin of the
event loop, no other code can run in the meantime. That means you can
be sure that while your object is lying in pieces on the floor, nobody
else can poke at it before you put it back together again.</p>

<p>Once you add coroutines, you never know when someone might call
<code>yield</code>.  Any function you call has the right to pause and resume you
whenever they want, <em>even after any number of spins of the event
loop</em>. Now any time you find yourself modifying state, you start
worrying that calling a function might interrupt some code you
intended to be transactional. Take something as simple as swapping a
couple fields of an object:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">=</span> <span class="nx">munge</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>What happens if <code>munge</code> does a <code>yield</code> and only resumes your code
after a few other events fire? Those events could interact with <code>obj</code>,
and they'd see it in this intermediate state where both <code>obj.foo</code> and
<code>obj.bar</code> are the same value, because <code>obj.bar</code> hasn't yet been
updated.</p>

<p>We've seen this movie before. This is just like Java's threads, where
any time you're working with state, you have to worry about who might
try to touch your data before it reaches a stable point. To be fair,
life is actually far worse in Java, where almost every single basic
operation of the language can be pre-empted. But still, with
coroutines, every function call becomes a potential pre-emption point.</p>

<h2>Host frames make coroutines unportable</h2>

<p>And then there's the implementation problem. Unless your JavaScript
engine doesn't use a stack (and they all do), coroutines would have to
be able to save a stack on the heap and restore it back on the stack
later. But what if JavaScript code calls into code implemented in the
host language (usually C++)? Some engines implement functions like
<code>Array.prototype.forEach</code> in C++. How would they handle code like
this?</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Fiber</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok: &#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Other languages with coroutines take different approaches.  Lua allows
implementations to <a href="http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield">throw an error</a>
if user code tries to suspend host activations. This would simply be
unportable, since different engines would implement different standard
libraries in C++.</p>

<p>The Scheme community tends to demand a lot from their continuations,
so they expect functions like <code>for-each</code> and <code>map</code> to be
suspended. This could mean either forcing all the standard libraries
to be self-hosted, or using more complicated <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.9076">implementation strategies</a>
than traditional stacks.</p>

<p>Simply put: browser vendors are not going to do this. Modern JS
engines are extraordinary feats of engineering, and rearchitecting
their entire stack mechanism is just not realistic. Then when you
consider that these changes could hurt performance of ordinary
function calls, well... end of discussion.</p>

<h2>Shallow coroutines to the rescue</h2>

<p>OK, back to the pyramid of doom. It really does kind of suck. I mean,
you could name and lift out your functions, but then you break up the
sequential flow even worse, and you get a combinatorial explosion of
function arguments for all those upvars.</p>

<p>This is why I'm excited about
<a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>. Generators
are a lot like coroutines, with one important difference: <em>they only
suspend their own function activation</em>. In ES6, <code>yield</code> isn't a
function that anyone can use, it's a built-in operator that only a
generator function can use. With generators, calling a JS function is
as benign as it ever was. You never have to worry that a function call
might <code>yield</code> and stop you from doing what you were trying to do.</p>

<p>But it's still possible to build an API similar to node-fibers. This
is the idea of <a href="https://github.com/dherman/taskjs">task.js</a>. The
fibers example looks pretty similar in task.js:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">Task</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;wait... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="nx">yield</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;ok... &#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}).</span><span class="nx">run</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The big difference is that the <code>sleep</code> function doesn't <em>implicitly</em>
yield; instead, it returns a
<a href="http://blogs.msdn.com/b/ie/archive/2011/09/11/asynchronous-programming-in-javascript-with-promises.aspx">promise</a>. The
task then <em>explicitly</em> <code>yield</code>s the promise back to the task.js
scheduler. When the promise is fulfilled, the scheduler wakes the task
back up to continue. Hardly any wordier than node-fibers, but with the
benefit that you can always tell when and what you're suspending.</p>

<h2>Coroutines no, generators yes</h2>

<p>Coroutines are not going to happen in JavaScript. They would break one
of the best features of JavaScript: the simplicity of the event loop
execution model. And the demands they would place on current engines
for portability are simply unrealistic. But generator functions are
easy to add to existing engines, they have none of the portability
issues of coroutines, and they give you just enough power to write
non-blocking I/O in a synchronous style without being "threads lite."</p>
]]></content>
  </entry>
  
</feed>
